local success, errorMsg = pcall(function()

local LocalPlayer = game:GetService("Players").LocalPlayer
local RunService = game:GetService("RunService")

-- ESP Variables
espRToggled = false
espBToggled = false
espIToggled = false
espCuToggled = false  -- Fixed typo
espBossToggled = false

-- Auto Face Variables
autoFaceToggled = false
autoFaceConnection = nil

-- Boss ESP Fixed
local bossFolder = nil
local bossESPConnection = nil

local function updateBossESP()
    pcall(function()
        local sleepyHollow = workspace:WaitForChild("Sleepy Hollow", 5)
        if not sleepyHollow then return end
        
        local modes = sleepyHollow:FindFirstChild("Modes")
        if not modes then return end
        
        local boss = modes:FindFirstChild("Boss")
        if not boss then return end
        
        bossFolder = boss:FindFirstChild("HeadlessHorsemanBoss")
        
        if bossFolder then
            -- Remove old highlights if toggled off
            if not espBossToggled then
                for _, child in pairs(bossFolder:GetChildren()) do
                    if child:FindFirstChild("Highlight") then
                        child.Highlight:Destroy()
                    end
                end
                return
            end
            
            -- Add highlights to existing bosses
            for _, child in pairs(bossFolder:GetChildren()) do
                if child and child.Parent and not child:FindFirstChild("Highlight") then
                    local Highlight = Instance.new("Highlight")
                    Highlight.Parent = child
                    Highlight.Adornee = child
                    Highlight.FillColor = Color3.fromRGB(255, 0, 0)
                    Highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
                    Highlight.OutlineTransparency = 0.5
                end
            end
        end
    end)
end

-- Setup Boss ESP with ChildAdded listener
local function setupBossESP()
    if bossESPConnection then
        bossESPConnection:Disconnect()
        bossESPConnection = nil
    end
    
    task.spawn(function()
        while task.wait(2) do
            if not espBossToggled then  -- Exit if off
                return
            end
            updateBossESP()
            
            if bossFolder and not bossESPConnection then
                bossESPConnection = bossFolder.ChildAdded:Connect(function(child)
                    if espBossToggled and child and child.Parent then
                        task.wait(0.1)
                        if not child:FindFirstChild("Highlight") then
                            local Highlight = Instance.new("Highlight")
                            Highlight.Parent = child
                            Highlight.Adornee = child
                            Highlight.FillColor = Color3.fromRGB(255, 0, 0)
                            Highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
                            Highlight.OutlineTransparency = 0.5
                        end
                    end
                end)
            elseif not bossFolder and bossESPConnection then  -- Disconnect if folder gone
                bossESPConnection:Disconnect()
                bossESPConnection = nil
            end
        end
    end)
end

setupBossESP()

workspace.Camera.ChildAdded:Connect(function(child)
    if child.Name == "m_Zombie" then
        local Origin = child:WaitForChild("Orig", 5)
        if Origin and Origin.Value ~= nil then
            local zombie = Origin.Value:FindFirstChild("Zombie")
            if not zombie then return end
            
            if espRToggled and zombie.WalkSpeed > 16 then
                local Highlight = Instance.new("Highlight")
                Highlight.Parent = child
                Highlight.Adornee = child
            end
            
            if espBToggled and child:FindFirstChild("Barrel") ~= nil then
                local Highlight = Instance.new("Highlight")
                Highlight.Parent = child
                Highlight.Adornee = child
                Highlight.FillColor = Color3.fromRGB(65,105,225)
            end
            
            if espIToggled and child:FindFirstChild("Whale Oil Lantern") ~= nil then
                local Highlight = Instance.new("Highlight")
                Highlight.Parent = child
                Highlight.Adornee = child
                Highlight.FillColor = Color3.fromRGB(255,255,51)
            end
            
            if espCuToggled and child:FindFirstChild("Sword") ~= nil then  -- Fixed typo
                local Highlight = Instance.new("Highlight")
                Highlight.Parent = child
                Highlight.Adornee = child
                Highlight.FillColor = Color3.fromRGB(65,105,225)  
            end
        end
    end
end)

-- ESP Players (Fixed: Separate toggles)
espMedicToggled = false  -- สำหรับ health <60
espInfectionToggled = false  -- สำหรับ infection >10

function checkPlayersLife()
    -- Remove all highlights if both off
    if not espMedicToggled and not espInfectionToggled then
        local Players = workspace.Players:GetChildren()
        for i, player in pairs(Players) do
            if player:FindFirstChild("Highlight") then
                player.Highlight:Destroy()
            end
        end
        return  -- Exit early
    end

    while espMedicToggled or espInfectionToggled do
        local Players = workspace.Players:GetChildren()
        for i, player in pairs(Players) do
            -- Medic ESP (health check)
            if espMedicToggled then
                local humanoid = player:FindFirstChild("Humanoid")
                if humanoid and humanoid.Health < 60 and player.Name ~= LocalPlayer.Name and 
                   (LocalPlayer.Backpack:FindFirstChild("Medical Supplies") or 
                   (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Medical Supplies"))) then
                    if not player:FindFirstChild("Highlight") then
                        local Highlight = Instance.new("Highlight")
                        Highlight.Parent = player
                        Highlight.Adornee = player
                        Highlight.FillColor = Color3.fromRGB(255, 169, 108)
                        Highlight.FillTransparency = 0.8
                        Highlight.OutlineColor = Color3.fromRGB(255, 206, 108)
                        Highlight.OutlineTransparency = 0.2
                    end
                else
                    if player:FindFirstChild("Highlight") then  -- Remove if not condition
                        player.Highlight:Destroy()
                    end
                end
            end

            -- Infection ESP (separate)
            if espInfectionToggled then
                if LocalPlayer.Backpack:FindFirstChild("Mercy") or 
                   (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Mercy")) then
                    local userStates = player:FindFirstChild("UserStates")
                    if userStates and userStates:FindFirstChild("Infected") then
                        local infectedVal = userStates.Infected.Value
                        if infectedVal > 10 then
                            local existingHighlight = player:FindFirstChild("Highlight")
                            if infectedVal > 89 then
                                local Highlight = existingHighlight or Instance.new("Highlight")
                                Highlight.Parent = player
                                Highlight.Adornee = player
                                Highlight.FillColor = Color3.fromRGB(178,34,34)
                            else
                                if not existingHighlight then
                                    local Highlight = Instance.new("Highlight")
                                    Highlight.Parent = player
                                    Highlight.Adornee = player
                                    Highlight.FillColor = Color3.fromRGB(255, 169, 108)
                                    Highlight.FillTransparency = 0.8
                                    Highlight.OutlineColor = Color3.fromRGB(255, 206, 108)
                                    Highlight.OutlineTransparency = 0.2
                                end
                            end
                        elseif player:FindFirstChild("Highlight") and infectedVal == 0 then
                            player.Highlight:Destroy()
                        end
                    end
                end
            end
        end
        task.wait(2.0)
    end
end

toolEquip = true

-- ===== OPTIMIZED: Kill & Shove Aura =====
observerOnline = false
killAuraToggled = false
shoveAuraToggled = false
isDead = false
killAuraConnection = nil

-- OPTIMIZED: Shove ตั้งค่าใหม่
shoveRadius = 8
maxShovePerCycle = 30  -- เพิ่มจาก 20
local stunCooldowns = {}
local lastShoveTime = 0
local shoveStunCooldown = 0.15  -- ลดจาก 0.3

-- Kill Aura ตั้งค่า
local lastAttackTime = 0
local killAuraRadius = 13
local maxKillPerCycle = 1
local adaptiveKillDelay = 0.2
local adaptiveAttackDelay = 0.2
local killAuraActive = true
local cycleStartTime = tick()
local cycleDuration = 0.1
local pauseDuration = 1.0

local currentPing = 0
local lagCompensationMultiplier = 1.0

local function updatePing()
    task.spawn(function()
        while task.wait(2) do
            pcall(function()
                currentPing = Stats.Network.ServerStatsItem["Data Ping"]:GetValue()
                
                if currentPing > 200 then
                    lagCompensationMultiplier = 1.3
                    adaptiveAttackDelay = 0.3
                    pauseDuration = 1.5
                elseif currentPing > 100 then
                    lagCompensationMultiplier = 1.15
                    adaptiveAttackDelay = 0.25
                    pauseDuration = 1.2
                else
                    lagCompensationMultiplier = 1.0
                    adaptiveAttackDelay = 0.2
                    pauseDuration = 1.0
                end
            end)
        end
    end)
end

updatePing()

local raycastParams = RaycastParams.new()
raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
raycastParams.FilterType = Enum.RaycastFilterType.Exclude

local params = OverlapParams.new()
params.FilterDescendantsInstances = {LocalPlayer.Character}

function getEquippedWeapon()
    if not LocalPlayer.Character then return nil end
    
    for _, child in pairs(LocalPlayer.Character:GetChildren()) do
        if child:IsA("Tool") then
            if child:FindFirstChild("RemoteEvent") or child:FindFirstChild("Remote") then
                return child
            end
        end
    end
    
    for _, child in pairs(LocalPlayer.Backpack:GetChildren()) do
        if child:IsA("Tool") and child.Parent == LocalPlayer.Character then
            if child:FindFirstChild("RemoteEvent") or child:FindFirstChild("Remote") then
                return child
            end
        end
    end
    
    return nil
end

function canWeaponShove(weapon)
    if not weapon then return false end
    
    local shoveWeapons = {
        "Pickaxe", 
        "Axe",
        "Carbine",
        "Navy Pistol",
        "Baguette"
    }
    
    for _, shoveWeapon in pairs(shoveWeapons) do
        if weapon.Name:lower():find(shoveWeapon:lower()) then
            return true
        end
    end
    
    if weapon:GetAttribute("CanShove") == true then
        return true
    end
    
    return false
end

-- OPTIMIZED: Batch Shove Attack
function batchShoveAttack(weapon, zombieList)
    if not weapon or #zombieList == 0 then return end
    
    local currentTime = tick()
    local remoteEvent = weapon:FindFirstChild("RemoteEvent") or weapon:FindFirstChild("Remote")
    if not remoteEvent then return end
    
    local weaponName = weapon.Name:lower()
    
    for i, zombieData in ipairs(zombieList) do
        local hit = zombieData.hit
        local zombieId = tostring(hit)
        
        stunCooldowns[zombieId] = currentTime
        
        task.spawn(function()
            pcall(function()
                remoteEvent:FireServer("FeedbackStun", hit, zombieData.hitPart.Position)
                
                if weaponName:find("axe") then
                    remoteEvent:FireServer("BraceBlock")
                    remoteEvent:FireServer("StopBraceBlock")
                    remoteEvent:FireServer("FeedbackStunObject", hit, zombieData.hitPart.Position)
                elseif weaponName:find("pickaxe") then
                    remoteEvent:FireServer("Swing", "Shove")
                    remoteEvent:FireServer("FeedbackStun", hit, zombieData.hitPart.Position)
                elseif weaponName:find("carbine") then
                    remoteEvent:FireServer("Shove")
                    remoteEvent:FireServer("FeedbackStun", hit, zombieData.hitPart.Position)
                elseif weaponName:find("navy pistol") then
                    remoteEvent:FireServer("Shove")
                elseif weaponName:find("baguette") then
                    remoteEvent:FireServer("FeedbackStun", hit, zombieData.hitPart.Position)
                end
                
                local replicatedStorage = game:GetService("ReplicatedStorage")
                if replicatedStorage:FindFirstChild("Remotes") then
                    local remotes = replicatedStorage.Remotes
                    if remotes:FindFirstChild("Stun") then
                        remotes.Stun:FireServer(hit)
                    end
                    if remotes:FindFirstChild("ZombieStun") then
                        remotes.ZombieStun:FireServer(hit)
                    end
                end
            end)
        end)
    end
end

function getPredictedPosition(zombie, currentPos, velocity)
    if not zombie or not currentPos then return currentPos end
    
    local predictionTime = (currentPing / 1000) * lagCompensationMultiplier
    local predictedPos = currentPos + (velocity * predictionTime)
    
    return predictedPos
end

function attackWithWeapon(weapon, hit, hitPart, calc, normal)
    if not weapon then return end
    
    local remoteEvent = weapon:FindFirstChild("RemoteEvent") or weapon:FindFirstChild("Remote")
    if not remoteEvent then return end
    
    pcall(function()
        game:GetService("ReplicatedStorage").Remotes.Gib:FireServer(hit, "Head", hitPart.CFrame.Position, normal, true)
    end)
    
    local success = false
    
    pcall(function()
        remoteEvent:FireServer("Swing", "Thrust")
        remoteEvent:FireServer("HitZombie", hit, hitPart.CFrame.Position, true, calc * 25, "Head", normal)
        success = true
    end)
    
    if not success then
        pcall(function()
            remoteEvent:FireServer("Bayonet_HitZombie", hit, hitPart.CFrame.Position, true, "Head")
            success = true
        end)
    end
    
    if not success then
        pcall(function()
            remoteEvent:FireServer("HitZombie", hit, hitPart.CFrame.Position, true, calc * 25, "Head", normal)
        end)
    end
end

function detectEnemy(hitbox, hrp)
    if killAuraConnection then
        killAuraConnection:Disconnect()
    end
    
    killAuraConnection = RunService.Heartbeat:Connect(function()
        if not killAuraToggled and not shoveAuraToggled then
            isDead = false
            observerOnline = false
            killAuraActive = true
            if killAuraConnection then
                killAuraConnection:Disconnect()
                killAuraConnection = nil
            end
            return
        end

        if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            return
        end

        if not hitbox or not hitbox.Parent then
            return
        end

        local currentTime = tick()
        
        if killAuraToggled then
            local elapsed = currentTime - cycleStartTime
            if elapsed > cycleDuration + pauseDuration then
                cycleStartTime = currentTime
                killAuraActive = true
            elseif elapsed > cycleDuration then
                killAuraActive = false
                return
            end
        end
        
        local success, parts = pcall(function()
            return workspace:GetPartsInPart(hitbox, params)
        end)

        if not success then
            return
        end

        local zombiesToShove = {}
        local zombiesToAttack = {}
        local equippedWeapon = getEquippedWeapon()

        for i, part in pairs(parts) do
            if part.Parent and part.Parent.Name == "m_Zombie" then
                local Origin = part.Parent:FindFirstChild("Orig")
                if Origin and Origin.Value then
                    local zombie = Origin.Value:FindFirstChild("Zombie")
                    if zombie then
                        local hit = Origin.Value
                        local head = hit:FindFirstChild("Head")
                        local zombieHRP = hit:FindFirstChild("HumanoidRootPart")
                        
                        if head and zombieHRP then
                            local velocity = zombieHRP.AssemblyLinearVelocity or Vector3.new(0,0,0)
                            local predictedPos = getPredictedPosition(zombie, zombieHRP.Position, velocity)
                            local distance = (predictedPos - hrp.Position).Magnitude
                            
                            -- OPTIMIZED: Shove Aura
                            if shoveAuraToggled and equippedWeapon and canWeaponShove(equippedWeapon) and distance <= shoveRadius then
                                local zombieId = tostring(hit)
                                if not stunCooldowns[zombieId] or currentTime - stunCooldowns[zombieId] >= shoveStunCooldown then
                                    local raycastResult = workspace:Raycast(hrp.CFrame.Position, head.CFrame.Position - hrp.CFrame.Position, raycastParams)
                                    if raycastResult then
                                        table.insert(zombiesToShove, {
                                            hit = hit, 
                                            hitPart = head,
                                            zombie = zombie, 
                                            raycast = raycastResult,
                                            priority = zombie.WalkSpeed > 16 and 1 or 2,
                                            distance = distance
                                        })
                                    end
                                end
                            end
                            
                            -- Kill Aura
                            if killAuraToggled and killAuraActive and distance <= killAuraRadius then
                                local zombieId = tostring(hit)
                                local willBeShoved = false
                                
                                if shoveAuraToggled and equippedWeapon and canWeaponShove(equippedWeapon) and distance <= shoveRadius then
                                    if not stunCooldowns[zombieId] or currentTime - stunCooldowns[zombieId] >= shoveStunCooldown then
                                        willBeShoved = true
                                    end
                                end
                                
                                if not willBeShoved then
                                    local raycastResult = workspace:Raycast(hrp.CFrame.Position, head.CFrame.Position - hrp.CFrame.Position, raycastParams)
                                    if raycastResult then
                                        local calc = (raycastResult.Position - hrp.CFrame.Position)
                                        if calc:Dot(calc) > 1 then
                                            calc = calc.Unit
                                        end
                                        
                                        table.insert(zombiesToAttack, {
                                            hit = hit,
                                            part = part,
                                            zombie = zombie,
                                            raycast = raycastResult,
                                            calc = calc,
                                            priority = zombie.WalkSpeed > 16 and 1 or 2,
                                            distance = distance
                                        })
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        -- OPTIMIZED: Batch Shove
        if #zombiesToShove > 0 and equippedWeapon and canWeaponShove(equippedWeapon) and toolEquip then
            table.sort(zombiesToShove, function(a, b) 
                if a.priority ~= b.priority then
                    return a.priority < b.priority
                end
                return a.distance < b.distance
            end)
            
            local shoveCount = math.min(#zombiesToShove, maxShovePerCycle)
            local batchList = {}
            
            for i = 1, shoveCount do
                table.insert(batchList, zombiesToShove[i])
            end
            
            batchShoveAttack(equippedWeapon, batchList)
            
            lastShoveTime = currentTime
            return
        end
        
        -- Kill Aura
        if #zombiesToAttack > 0 and equippedWeapon and toolEquip and killAuraActive then
            if currentTime - lastAttackTime < adaptiveKillDelay then
                return
            end
            
            table.sort(zombiesToAttack, function(a, b) 
                if a.priority ~= b.priority then
                    return a.priority < b.priority
                end
                return a.distance < b.distance
            end)
            
            local killCount = math.min(#zombiesToAttack, maxKillPerCycle)
            
            for i = 1, killCount do
                local zombieData = zombiesToAttack[i]
                task.spawn(function()
                    if zombieData.zombie.WalkSpeed > 16 then
                        attackWithWeapon(equippedWeapon, zombieData.hit, zombieData.hit.Head, zombieData.calc, zombieData.raycast.Normal)
                    else
                        if not zombieData.part.Parent:FindFirstChild("Barrel") then
                            attackWithWeapon(equippedWeapon, zombieData.hit, zombieData.hit.Head, zombieData.calc, zombieData.raycast.Normal)
                        end
                    end
                end)
                
                if i < killCount then
                    task.wait(adaptiveAttackDelay)
                end
            end
            
            lastAttackTime = currentTime
        end
    end)
end

function startAutoFace()
    if autoFaceConnection then return end
    autoFaceConnection = RunService.Heartbeat:Connect(function()
        if not (killAuraToggled or shoveAuraToggled) or not autoFaceToggled then return end
        local hrp = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local activeRadius = math.max((killAuraToggled and killAuraRadius or 0), (shoveAuraToggled and shoveRadius or 0))
        if activeRadius == 0 then return end
        local nearestDist = math.huge
        local nearestTarget = nil
        for _, agent in pairs(workspace.Zombies:GetChildren()) do
            local zombieHRP = agent:FindFirstChild("HumanoidRootPart")
            if zombieHRP then
                local dist = (zombieHRP.Position - hrp.Position).Magnitude
                if dist < nearestDist and dist <= activeRadius then
                    nearestDist = dist
                    nearestTarget = zombieHRP
                end
            end
        end
        for _, child in pairs(workspace.Camera:GetChildren()) do
            if child.Name == "m_Zombie" then
                local Origin = child:FindFirstChild("Orig")
                if Origin and Origin.Value then
                    local zombieHRP = Origin.Value:FindFirstChild("HumanoidRootPart")
                    if zombieHRP then
                        local dist = (zombieHRP.Position - hrp.Position).Magnitude
                        if dist < nearestDist and dist <= activeRadius then
                            nearestDist = dist
                            nearestTarget = zombieHRP
                        end
                    end
                end
            end
        end
        if nearestTarget then
            hrp.CFrame = CFrame.new(hrp.Position, nearestTarget.Position)
        end
    end)
end

function stopAutoFace()
    if autoFaceConnection then
        autoFaceConnection:Disconnect()
        autoFaceConnection = nil
    end
end

function setShoveRadius(newRadius)
    shoveRadius = newRadius
    
    if (killAuraToggled or shoveAuraToggled) and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        observerOnline = false
        if killAuraConnection then
            killAuraConnection:Disconnect()
            killAuraConnection = nil
        end
        
        local existingHitbox = LocalPlayer.Character.HumanoidRootPart:FindFirstChild("Hitbox")
        if existingHitbox then
            existingHitbox:Destroy()
        end
        
        task.wait(0.1)
        createHitBox()
    end
end

function setMaxShovePerCycle(newMax)
    maxShovePerCycle = newMax
end

function setMaxKillPerCycle(newMax)
    maxKillPerCycle = newMax
end

function createHitBox()
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end

    local torso = LocalPlayer.Character.HumanoidRootPart
    local existingHitbox = torso:FindFirstChild("Hitbox")
    
    local hitboxSize, hitboxOffset
    
    if shoveAuraToggled and not killAuraToggled then
        hitboxSize = Vector3.new(shoveRadius * 2, 6, shoveRadius * 2)
        hitboxOffset = CFrame.new(0, 0, -shoveRadius * 0.6)
    elseif killAuraToggled and not shoveAuraToggled then
        hitboxSize = Vector3.new(killAuraRadius * 2, 7, killAuraRadius * 2)
        hitboxOffset = CFrame.new(0, 0, -killAuraRadius * 0.6)
    else
        local maxRadius = math.max(shoveRadius, killAuraRadius)
        hitboxSize = Vector3.new(maxRadius * 2, 7, maxRadius * 2)
        hitboxOffset = CFrame.new(0, 0, -maxRadius * 0.6)
    end
    
    if existingHitbox then
        existingHitbox.Size = hitboxSize
        existingHitbox.CFrame = torso.CFrame * hitboxOffset
        
        if not observerOnline then
            observerOnline = true
            detectEnemy(existingHitbox, torso)
        end
        return true
    else
        local hitbox = Instance.new("Part")
        hitbox.Name = "Hitbox"
        hitbox.Parent = torso
        hitbox.Anchored = false
        hitbox.Massless = true
        hitbox.CanCollide = false
        hitbox.CanTouch = false
        hitbox.Transparency = 1
        hitbox.Size = hitboxSize
        hitbox.CFrame = torso.CFrame * hitboxOffset

        local weld = Instance.new("WeldConstraint")
        weld.Parent = torso
        weld.Part0 = hitbox
        weld.Part1 = torso

        if not observerOnline then
            observerOnline = true
            detectEnemy(hitbox, torso)
        end

        return true
    end
end

-- OPTIMIZED: Cleanup ทำบ่อยขึ้น
task.spawn(function()
    while true do
        task.wait(3)
        local currentTime = tick()
        for zombieId, lastTime in pairs(stunCooldowns) do
            if currentTime - lastTime > 5 then
                stunCooldowns[zombieId] = nil
            end
        end
    end
end)
-- (จากเดิม: createHitBox function – ต้องมีเพื่อให้ setShoveRadius ทำงาน)
function createHitBox()
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end

    local torso = LocalPlayer.Character.HumanoidRootPart
    local existingHitbox = torso:FindFirstChild("Hitbox")
    
    local hitboxSize, hitboxOffset
    
    if shoveAuraToggled and not killAuraToggled then
        hitboxSize = Vector3.new(shoveRadius * 2, 6, shoveRadius * 2)
        hitboxOffset = CFrame.new(0, 0, -shoveRadius * 0.6)
    elseif killAuraToggled and not shoveAuraToggled then
        hitboxSize = Vector3.new(killAuraRadius * 2, 7, killAuraRadius * 2)
        hitboxOffset = CFrame.new(0, 0, -killAuraRadius * 0.6)
    else
        local maxRadius = math.max(shoveRadius, killAuraRadius)
        hitboxSize = Vector3.new(maxRadius * 2, 7, maxRadius * 2)
        hitboxOffset = CFrame.new(0, 0, -maxRadius * 0.6)
    end
    
    if existingHitbox then
        existingHitbox.Size = hitboxSize
        existingHitbox.CFrame = torso.CFrame * hitboxOffset
        
        if not observerOnline then
            observerOnline = true
            detectEnemy(existingHitbox, torso)
        end
        return true
    else
        local hitbox = Instance.new("Part")
        hitbox.Name = "Hitbox"
        hitbox.Parent = torso
        hitbox.Anchored = false
        hitbox.Massless = true
        hitbox.CanCollide = false
        hitbox.CanTouch = false
        hitbox.Transparency = 1
        hitbox.Size = hitboxSize
        hitbox.CFrame = torso.CFrame * hitboxOffset

        local weld = Instance.new("WeldConstraint")
        weld.Parent = torso
        weld.Part0 = hitbox
        weld.Part1 = torso

        if not observerOnline then
            observerOnline = true
            detectEnemy(hitbox, torso)
        end

        return true
    end
end

function onLights()
    local ligthPost = workspace:FindFirstChild("Saint Petersburg")
    if not ligthPost then return end
    
    local modes = ligthPost:FindFirstChild("Modes")
    if not modes then return end
    
    local holdout = modes:FindFirstChild("Holdout")
    if not holdout then return end
    
    local lampPosts = holdout:FindFirstChild("LampPosts")
    if not lampPosts then return end
    
    for _, part in pairs(lampPosts:GetChildren()) do
        local metal = part:FindFirstChild("Metal")
        if metal and metal:FindFirstChild("Light") then
            metal.Light.PointLight.Enabled = true
            metal.Light.Visible = true
        end
    end
end

local connection = nil

local function changeWalkSpeed(newValue, walkSpeedToggled)
    local workPlayer = LocalPlayer.Character
    if workPlayer and workPlayer:FindFirstChild("Humanoid") then
        workPlayer.Humanoid.WalkSpeed = newValue
        if walkSpeedToggled then
            if connection then connection:Disconnect() end
            connection = workPlayer.Humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function() 
                workPlayer.Humanoid.WalkSpeed = newValue 
            end)
        else
            if connection then
                connection:Disconnect()
                connection = nil
            end
        end
    end
end

walkSpeedToggled = false
walkSpeedValue = 16

workspace.Players.ChildAdded:Connect(function(child)
    changeWalkSpeed(walkSpeedValue, walkSpeedToggled)
end)

-- Music
autoplay = false
local autoPlayConnection = nil
local lastUpdateAccuracy = 0
local updateInterval = 0.5
local autoStartConnection = nil
local colorCheckConnection = nil
local equippedConnections = {}
local originals = {}

local function changeMusicGUIColor(toWhite)
    local targetColor = toWhite and Color3.fromRGB(255, 255, 255) or nil
    local targetTransparency = toWhite and 0 or nil
    
    pcall(function()
        local playerGui = LocalPlayer:WaitForChild("PlayerGui")
        
        -- Fife
        local fifeGui = playerGui:FindFirstChild("FifeGui") or game:GetService("ReplicatedStorage").Modules.Weapons:FindFirstChild("Fife"):FindFirstChild("FifeGui")
        if fifeGui then
            local root = fifeGui:FindFirstChild("Root")
            if root then
                local bg = root:FindFirstChild("BG")
                if bg then
                    if toWhite and not originals.fife then
                        originals.fife = {bg.BackgroundColor3, bg.BackgroundTransparency}
                    end
                    if toWhite then
                        bg.BackgroundColor3 = targetColor
                        bg.BackgroundTransparency = targetTransparency
                    else
                        if originals.fife then
                            bg.BackgroundColor3 = originals.fife[1]
                            bg.BackgroundTransparency = originals.fife[2]
                        end
                    end
                end
            end
        end
        
        -- Drum
        local drumGui = playerGui:FindFirstChild("DrumGui") or game:GetService("ReplicatedStorage").Modules.Weapons:FindFirstChild("Drums"):FindFirstChild("DrumGui")
        if drumGui then
            local root = drumGui:FindFirstChild("Root")
            if root then
                local bg = root:FindFirstChild("BG")
                if bg then
                    if toWhite and not originals.drum then
                        originals.drum = {bg.BackgroundColor3, bg.BackgroundTransparency}
                    end
                    if toWhite then
                        bg.BackgroundColor3 = targetColor
                        bg.BackgroundTransparency = targetTransparency
                    else
                        if originals.drum then
                            bg.BackgroundColor3 = originals.drum[1]
                            bg.BackgroundTransparency = originals.drum[2]
                        end
                    end
                end
            end
        end
        
        -- Bagpipes
        local bagpipesGui = playerGui:FindFirstChild("BagpipesGui") or game:GetService("ReplicatedStorage").Modules.Weapons:FindFirstChild("Bagpipes"):FindFirstChild("BagpipesGui")
        if bagpipesGui then
            local root = bagpipesGui:FindFirstChild("Root")
            if root then
                local bg = root:FindFirstChild("BG")
                if bg then
                    if toWhite and not originals.bagpipe then
                        originals.bagpipe = {bg.BackgroundColor3, bg.BackgroundTransparency}
                    end
                    if toWhite then
                        bg.BackgroundColor3 = targetColor
                        bg.BackgroundTransparency = targetTransparency
                    else
                        if originals.bagpipe then
                            bg.BackgroundColor3 = originals.bagpipe[1]
                            bg.BackgroundTransparency = originals.bagpipe[2]
                        end
                    end
                end
            end
        end
    end)
end

local function autoStartSong()
    if not autoplay then return end
    if not LocalPlayer.Character then return end
    
    pcall(function()
        for _, tool in pairs(LocalPlayer.Character:GetChildren()) do
            if tool:IsA("Tool") and (tool.Name:find("Fife") or tool.Name:find("Drum") or tool.Name:find("Bagpipe")) then
                local remoteEvent = tool:FindFirstChild("RemoteEvent")
                if remoteEvent then
                    local songSource = tool:FindFirstChild("Model") and 
                                      tool.Model:FindFirstChild("Handle") and 
                                      tool.Model.Handle:FindFirstChild("SoundSource")
                    
                    if songSource and not songSource.IsPlaying then
                        remoteEvent:FireServer("Play", "La Marseillaise")
                        task.wait(0.5)
                    end
                end
            end
        end
    end)
end

local function autoPerfectPlay()
    if not autoplay then return end
    if not LocalPlayer.Character then return end
    
    pcall(function()
        for _, tool in pairs(LocalPlayer.Character:GetChildren()) do
            if tool:IsA("Tool") and (tool.Name:find("Fife") or tool.Name:find("Drum") or tool.Name:find("Bagpipe")) then
                local remoteEvent = tool:FindFirstChild("RemoteEvent")
                if remoteEvent then
                    remoteEvent:FireServer("UpdateAccuracy", 100)
                    break
                end
            end
        end
    end)
end

local function startAutoPlay()
    if autoPlayConnection then
        autoPlayConnection:Disconnect()
    end
    if autoStartConnection then
        task.cancel(autoStartConnection)
    end
    if colorCheckConnection then
        colorCheckConnection:Disconnect()
    end
    
    lastUpdateAccuracy = 0
    
    changeMusicGUIColor(true)
    
    autoStartConnection = task.spawn(function()
        while autoplay do
            autoStartSong()
            task.wait(2)
        end
    end)
    
    autoPlayConnection = RunService.Heartbeat:Connect(function(deltaTime)
        if not autoplay then
            if autoPlayConnection then
                autoPlayConnection:Disconnect()
                autoPlayConnection = nil
            end
            if autoStartConnection then
                task.cancel(autoStartConnection)
                autoStartConnection = nil
            end
            changeMusicGUIColor(false)
            return
        end
        
        lastUpdateAccuracy = lastUpdateAccuracy - deltaTime
        
        if lastUpdateAccuracy <= 0 then
            lastUpdateAccuracy = updateInterval
            autoPerfectPlay()
        end
    end)
    
    local lastColorCheck = 0
    colorCheckConnection = RunService.Heartbeat:Connect(function(time, delta)
        if autoplay and time - lastColorCheck >= 0.5 then
            changeMusicGUIColor(true)
            lastColorCheck = time
        end
    end)
end

LocalPlayer.CharacterAdded:Connect(function(character)
    character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") and (child.Name:find("Fife") or child.Name:find("Drum") or child.Name:find("Bagpipe")) then
            if equippedConnections[child] then
                equippedConnections[child]:Disconnect()
            end
            equippedConnections[child] = child.Equipped:Connect(function()
                if autoplay then
                    task.wait(0.5)
                    changeMusicGUIColor(true)
                end
            end)
        end
    end)
    
    character.ChildRemoved:Connect(function(child)
        if equippedConnections[child] then
            equippedConnections[child]:Disconnect()
            equippedConnections[child] = nil
        end
    end)
end)

-- Bayonet Head Lock (Fixed: pcall require)
local FlintLockSuccess, FlintLock = pcall(require, game:GetService("ReplicatedStorage").Modules.Weapons:FindFirstChild("Flintlock"))
if not FlintLockSuccess then
    warn("Flintlock module not found!")
else
    local originBayonet = FlintLock.BayonetHitCheck

    local v_u_1 = {}
    v_u_1.__index = v_u_1

    function v_u_1.BayonetHitCheck(p115, p116, p117, p118, p119)
        local v120 = workspace:Raycast(p116, p117, p118)
        if v120 then
            if v120.Instance.Parent.Name == "m_Zombie" then
                local v121 = p118.FilterDescendantsInstances
                local v122 = v120.Instance
                table.insert(v121, v122)
                p118.FilterDescendantsInstances = v121
                local v123 = v120.Instance.Parent:FindFirstChild("Orig")
                if v123 then
                    local Head = nil
                    for i, part in pairs(v120.Instance.Parent:GetChildren()) do
                        if part.Name == "Head" and (part.ClassName == "Part" or part.ClassName == "MeshPart") then
                            Head = part
                            break
                        end
                    end
                    if Head then
                        p115.remoteEvent:FireServer("Bayonet_HitZombie", v123.Value, Head.CFrame.Position, true, "Head")
                        local v_u_124 = v123.Value
                        local v_u_125 = tick()
                        v_u_124:SetAttribute("WepHitID", tick())
                        v_u_124:SetAttribute("WepHitDirection", p117 * 10)
                        v_u_124:SetAttribute("WepHitPos", v120.Position)
                        task.delay(0.2, function()
                            if v_u_124:GetAttribute("WepHitID") == v_u_125 then
                                v_u_124:SetAttribute("WepHitDirection", nil)
                                v_u_124:SetAttribute("WepHitPos", nil)
                                v_u_124:SetAttribute("WepHitID", nil)
                            end
                        end)
                    end
                end
                return 1
            end
            local v126 = v120.Instance.Parent:FindFirstChild("DoorHit") or v120.Instance:FindFirstChild("BreakGlass")
            if v126 and not table.find(p119, v126) then
                table.insert(p119, v126)
                p115.remoteEvent:FireServer("Bayonet_HitCon", v120.Instance, v120.Position, v120.Normal, v120.Material)
                return 2
            end
            local v127 = v120.Instance.Parent:FindFirstChild("Humanoid") or v120.Instance.Parent.Parent:FindFirstChild("Humanoid")
            if v127 and not table.find(p119, v127) then
                table.insert(p119, v127)
                p115.remoteEvent:FireServer("Bayonet_HitPlayer", v127, v120.Position)
                return 2
            end
        end
        return 0
    end

    function changeBayonet(value)
        FlintLock.BayonetHitCheck = value and v_u_1.BayonetHitCheck or originBayonet
    end
end

-- Melee Head Lock (Fixed: pcall require)
local MeleeBaseSuccess, MeleeBase = pcall(require, game:GetService("ReplicatedStorage").Modules.Weapons:FindFirstChild("MeleeBase"))
if not MeleeBaseSuccess then
    warn("MeleeBase module not found!")
else
    local originMelee = MeleeBase.MeleeHitCheck

    local u1 = {}
    u1.__index = u1

    local u8 = game:GetService("CollectionService")
    local u10 = require(game.ReplicatedStorage:WaitForChild("Modules"):WaitForChild("RbxUtil"):WaitForChild("DebugVisualizer"))
    local v11 = game.Players.LocalPlayer:WaitForChild("Options")
    local u14 = v11:WaitForChild("Gore")
    local u15 = v11:WaitForChild("WeaponStains")
    local v5 = game.ReplicatedStorage:WaitForChild("GameStates"):WaitForChild("Gameplay")
    local u7 = v5:WaitForChild("PVP")

    function u1.MeleeHitCheck(p100, p101, p102, p103, p104, p105)
        local v106 = workspace:Raycast(p101, p102, p103)
        if v106 then
            if v106.Instance.Parent.Name == "m_Zombie" then
                local v107 = p103.FilterDescendantsInstances
                local v108 = v106.Instance
                table.insert(v107, v108)
                p103.FilterDescendantsInstances = v107
                local v109 = v106.Instance.Parent:FindFirstChild("Orig")
                if v109 then
                    if p100.sharp and shared.Gib ~= nil then
                        if v109.Value then
                            local v110 = v109.Value:FindFirstChild("Zombie")
                            local v111 = not p100.Stats.HeadshotMulti and 2.3 or p100.Stats.HeadshotMulti
                            if v110 and v110.Health - p100.Stats.Damage * v111 <= 0 then
                                shared.Gib(v109.Value, v106.Instance.Name, v106.Position, v106.Normal, true)
                            end
                        else
                            shared.Gib(v109.Value, v106.Instance.Name, v106.Position, v106.Normal, true)
                        end
                    end
                    if not p104[v109] or p104[v109] < (p100.Stats.MaxHits or 3) then
                        if p105 then
                            p100.remoteEvent:FireServer("ThrustCharge", v109.Value, v106.Position, v106.Normal)
                        else
                            local Head = nil
                            for i, part in pairs(v106.Instance.Parent:GetChildren()) do
                                if part.Name == "Head" and (part.ClassName == "Part" or part.ClassName == "MeshPart") then
                                    Head = part
                                    break
                                end
                            end
                            if Head then
                                local u112 = v109.Value
                                local v113 = Head.CFrame.Position - p101
                                if v113:Dot(v113) > 1 then
                                    v113 = v113.Unit
                                end
                                local v114 = v113 * 25
                                p100.remoteEvent:FireServer("HitZombie", u112, Head.CFrame.Position, true, v114, "Head", v106.Normal)
                                if not u112:GetAttribute("WepHitDirection") then
                                    local u115 = tick()
                                    u112:SetAttribute("WepHitID", tick())
                                    u112:SetAttribute("WepHitDirection", v114)
                                    u112:SetAttribute("WepHitPos", v106.Position)
                                    task.delay(0.2, function()
                                        if u112:GetAttribute("WepHitID") == u115 then
                                            u112:SetAttribute("WepHitDirection", nil)
                                            u112:SetAttribute("WepHitPos", nil)
                                            u112:SetAttribute("WepHitID", nil)
                                        end
                                    end)
                                end
                                u10:CastSphere("MeleeHitValid", CFrame.new(p101), Color3.fromRGB(0, 255, 0))
                                u10:CastSphere("PartPosition", CFrame.new(v106.Position), Color3.fromRGB(255, 85, 0))
                                u10:CastLine("MeleeHit", CFrame.new(p101, p101 + p102) * CFrame.new(0, 0, -p102.Magnitude / 2), Color3.fromRGB(0, 255, 0), p102.Magnitude / 1)
                            end
                        end
                        if p104[v109] then
                            p104[v109] = p104[v109] + 1
                        else
                            table.insert(p104, v109)
                            p104[v109] = 1
                            if u14.Value and (u15.Value and p100.player:GetAttribute("Platform") ~= "Console") then
                                local v116 = p100.bloodSaturation + 0.1
                                p100.bloodSaturation = math.min(v116, 1)
                            end
                        end
                    end
                end
                return 1
            end
            if not p105 then
                local v117 = v106.Instance.Parent:FindFirstChild("DoorHit") or v106.Instance:FindFirstChild("BreakGlass")
                if v117 and not table.find(p104, v117) then
                    table.insert(p104, v117)
                    p100.remoteEvent:FireServer("HitCon", v106.Instance)
                    u10:CastSphere("MeleeHitValid", CFrame.new(p101), Color3.fromRGB(0, 255, 0))
                    u10:CastLine("MeleeHit", CFrame.new(p101, p101 + p102) * CFrame.new(0, 0, -p102.Magnitude / 2), Color3.fromRGB(255, 255, 0), p102.Magnitude / 1)
                    return 2
                end
                local v118 = v106.Instance.Parent:FindFirstChild("Humanoid") or v106.Instance.Parent.Parent:FindFirstChild("Humanoid")
                if v118 and not table.find(p104, v118) then
                    table.insert(p104, v118)
                    p100.remoteEvent:FireServer("HitPlayer", v118, v106.Position)
                    u10:CastSphere("MeleeHitValid", CFrame.new(p101), Color3.fromRGB(0, 255, 0))
                    u10:CastLine("MeleeHit", CFrame.new(p101, p101 + p102) * CFrame.new(0, 0, -p102.Magnitude / 2), Color3.fromRGB(0, 255, 0), p102.Magnitude / 1)
                    return 2
                end
                if u7:GetAttribute("Active") == true then
                    local v119 = v106.Instance.Parent:FindFirstChild("BuildingHealth") or v106.Instance.Parent.Parent:FindFirstChild("BuildingHealth")
                    if v119 ~= nil and not table.find(p104, v119) then
                        table.insert(p104, v119)
                        local v120 = v119.Parent:FindFirstChild("Creator")
                        if v120 then
                            v120 = v120.Value
                        end
                        if v120 ~= nil and (v120.Neutral == false and (p100.player.Team ~= nil and (v120.Team ~= nil and p100.player.Team.Name == v120.Team.Name))) then
                            return 2
                        end
                        p100.remoteEvent:FireServer("HitBuilding", v119.Parent)
                        u10:CastSphere("MeleeHitValid", CFrame.new(p101), Color3.fromRGB(0, 255, 0))
                        u10:CastLine("MeleeHit", CFrame.new(p101, p101 + p102) * CFrame.new(0, 0, -p102.Magnitude / 2), Color3.fromRGB(255, 255, 0), p102.Magnitude / 1)
                        return 2
                    end
                end
                if p100.Stats.BreaksDown and u8:HasTag(v106.Instance, "Breakable") then
                    local v121 = OverlapParams.new()
                    v121.FilterDescendantsInstances = p103.FilterDescendantsInstances
                    local v122 = workspace:GetPartBoundsInRadius(v106.Position, 0.1, v121)
                    local v123 = {}
                    for v124 = 1, #v122 do
                        if u8:HasTag(v122[v124], "Breakable") then
                            local v125 = v122[v124]
                            table.insert(v123, v125)
                        end
                    end
                    p100.remoteEvent:FireServer("HitBreakable", v123, (v106.Position - p101).Unit)
                    u10:CastSphere("MeleeHitValid", CFrame.new(p101), Color3.fromRGB(0, 255, 0))
                    u10:CastLine("MeleeHit", CFrame.new(p101, p101 + p102) * CFrame.new(0, 0, -p102.Magnitude / 2), Color3.fromRGB(255, 255, 0), p102.Magnitude / 1)
                    return 2
                end
                u10:CastLine("MeleeHit", CFrame.new(p101, p101 + p102) * CFrame.new(0, 0, -p102.Magnitude / 2), Color3.fromRGB(255, 0, 0), p102.Magnitude / 1)
            end
        else
            u10:CastLine("MeleeHit", CFrame.new(p101, p101 + p102) * CFrame.new(0, 0, -p102.Magnitude / 2), Color3.fromRGB(255, 0, 0), p102.Magnitude / 1)
        end
        return 0
    end

    function changeMelee(value)
        MeleeBase.MeleeHitCheck = value and u1.MeleeHitCheck or originMelee
    end
end

-- Zombie Hitbox Expander
local hitboxEnabled = false
local hitboxSize = 10
local zombieFolder = workspace:WaitForChild("Zombies")

local function addOuterHitbox(zombie)
    if not zombie or not zombie.Parent then return end
    local hrp = zombie:FindFirstChild("HumanoidRootPart")
    if hrp and not zombie:FindFirstChild("OuterHitbox") then
        pcall(function()
            local part = Instance.new("Part")
            part.Name = "OuterHitbox"
            part.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
            part.Transparency = 1
            part.Anchored = false
            part.CanCollide = false
            part.Massless = true
            part.CanTouch = true
            part.CFrame = hrp.CFrame
            part.Parent = zombie

            local weld = Instance.new("WeldConstraint")
            weld.Part0 = hrp
            weld.Part1 = part
            weld.Parent = part
        end)
    end
end

local function addHeadHitbox(zombie)
    if not zombie or not zombie.Parent then end
    local head = zombie:FindFirstChild("Head")
    if head and not zombie:FindFirstChild("HeadHitbox") then
        pcall(function()
            local part = Instance.new("Part")
            part.Name = "HeadHitbox"
            part.Size = Vector3.new(hitboxSize/2, hitboxSize/2, hitboxSize/2)
            part.Transparency = 1
            part.Anchored = false
            part.CanCollide = false
            part.Massless = true
            part.CanTouch = true
            part.CFrame = head.CFrame
            part.Parent = zombie

            local weld = Instance.new("WeldConstraint")
            weld.Part0 = head
            weld.Part1 = part
            weld.Parent = part
        end)
    end
end

local function removeHitboxes(zombie)
    if not zombie then return end
    pcall(function()
        local outer = zombie:FindFirstChild("OuterHitbox")
        local head = zombie:FindFirstChild("HeadHitbox")
        if outer then outer:Destroy() end
        if head then head:Destroy() end
    end)
end

local function updateHitboxes(zombie)
    if not zombie then return end
    if hitboxEnabled then
        removeHitboxes(zombie)
        task.wait(0.05)
        addOuterHitbox(zombie)
        addHeadHitbox(zombie)
    else
        removeHitboxes(zombie)
    end
end

local function setHitboxSize(newSize)
    hitboxSize = newSize
    if hitboxEnabled then
        pcall(function()
            for _, zombie in pairs(zombieFolder:GetChildren()) do
                updateHitboxes(zombie)
            end
            for _, zombie in pairs(workspace.Camera:GetChildren()) do
                if zombie.Name == "m_Zombie" then
                    updateHitboxes(zombie)
                end
            end
        end)
    end
end

local function toggleHitboxExpander(enabled)
    hitboxEnabled = enabled
    
    pcall(function()
        for _, zombie in pairs(zombieFolder:GetChildren()) do
            updateHitboxes(zombie)
        end
        for _, zombie in pairs(workspace.Camera:GetChildren()) do
            if zombie.Name == "m_Zombie" then
                updateHitboxes(zombie)
            end
        end
    end)
end

zombieFolder.ChildAdded:Connect(function(zombie)
    if hitboxEnabled then
        task.wait(0.2)
        updateHitboxes(zombie)
    end
end)

workspace.Camera.ChildAdded:Connect(function(zombie)
    if zombie.Name == "m_Zombie" and hitboxEnabled then
        task.wait(0.2)
        updateHitboxes(zombie)
    end
end)

-- Fullbright
local Light = game:GetService("Lighting")
local fullbrightEnabled = false
local fullbrightConnection = nil
local originalLighting = {
    Ambient = Light.Ambient,
    ColorShift_Bottom = Light.ColorShift_Bottom,
    ColorShift_Top = Light.ColorShift_Top,
    OutdoorAmbient = Light.OutdoorAmbient,
    Brightness = Light.Brightness
}

local function doFullbright()
    if not fullbrightEnabled then return end
    Light.Ambient = Color3.new(1, 1, 1)
    Light.ColorShift_Bottom = Color3.new(1, 1, 1)
    Light.ColorShift_Top = Color3.new(1, 1, 1)
    Light.OutdoorAmbient = Color3.new(1, 1, 1)
    Light.Brightness = 2
end

local function restoreLighting()
    Light.Ambient = originalLighting.Ambient
    Light.ColorShift_Bottom = originalLighting.ColorShift_Bottom
    Light.ColorShift_Top = originalLighting.ColorShift_Top
    Light.OutdoorAmbient = originalLighting.OutdoorAmbient
    Light.Brightness = originalLighting.Brightness
end

local function toggleFullbright(enabled)
    fullbrightEnabled = enabled
    if fullbrightConnection then
        fullbrightConnection:Disconnect()
        fullbrightConnection = nil
    end
    
    if enabled then
        doFullbright()
        fullbrightConnection = Light.LightingChanged:Connect(doFullbright)
    else
        restoreLighting()
    end
end

-- Killbrick Protection
local killbrickEnabled = true
local killbrickConnection = nil

local function toggleKillbrick(enabled)
    killbrickEnabled = enabled
    if killbrickConnection then
        killbrickConnection:Disconnect()
        killbrickConnection = nil
    end
    
    if not enabled then
        killbrickConnection = RunService.Heartbeat:Connect(function()
            if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
            local parts = workspace:GetPartBoundsInRadius(LocalPlayer.Character.HumanoidRootPart.Position, 10)
            for _, part in ipairs(parts) do
                part.CanTouch = false
            end
        end)
    end
end

-- Auto Repair
local autoRepairToggled = false
local autoEquipHammerToggled = false
local autoRepairConnection = nil
local lastRepairTime = 0
local isRepairing = false

local function equipHammer()
    local hammer = LocalPlayer.Backpack:FindFirstChild("Hammer")
    if not hammer then return false end
    
    pcall(function()
        LocalPlayer.Character.Humanoid:EquipTool(hammer)
    end)
    
    task.wait(0.2)
    return LocalPlayer.Character:FindFirstChild("Hammer") ~= nil
end

local function performRepair()
    if isRepairing or not autoRepairToggled or not LocalPlayer.Character then return false end
    
    local currentTime = tick()
    if currentTime - lastRepairTime < 0.1 then return false end
    
    local hammerTool = LocalPlayer.Character:FindFirstChild("Hammer")
    
    if not hammerTool and autoEquipHammerToggled then
        if not equipHammer() then return false end
        hammerTool = LocalPlayer.Character:FindFirstChild("Hammer")
    end
    
    if not hammerTool then return false end
    
    isRepairing = true
    
    local remoteEvent = hammerTool:FindFirstChild("RemoteEvent")
    if not remoteEvent then
        isRepairing = false
        return false
    end
    
    local repairParams = RaycastParams.new()
    repairParams.IgnoreWater = true
    repairParams.FilterDescendantsInstances = {LocalPlayer.Character}
    repairParams.FilterType = Enum.RaycastFilterType.Exclude
    
    local head = LocalPlayer.Character:FindFirstChild("Head")
    if not head then
        isRepairing = false
        return false
    end
    
    local repaired = false
    pcall(function()
        local direction = workspace.CurrentCamera.CFrame.LookVector
        local raycast = workspace:Raycast(head.Position, direction * 8, repairParams)
        
        if raycast and raycast.Instance then
            local buildingHealth = raycast.Instance.Parent:FindFirstChild("BuildingHealth") or 
                                 raycast.Instance.Parent.Parent:FindFirstChild("BuildingHealth")
            local constructHealth = raycast.Instance:FindFirstChild("ConstructHealth")
            
            if buildingHealth or constructHealth then
                remoteEvent:FireServer("Repair", buildingHealth or constructHealth)
                lastRepairTime = currentTime
                repaired = true
            end
        end
    end)
    
    isRepairing = false
    return repaired
end

local function autoRepair(Value)
    autoRepairToggled = Value
    
    if autoRepairConnection then
        autoRepairConnection:Disconnect()
        autoRepairConnection = nil
    end
    
    if autoRepairToggled then
        isRepairing = false
        autoRepairConnection = RunService.Heartbeat:Connect(function()
            if not autoRepairToggled then
                if autoRepairConnection then
                    autoRepairConnection:Disconnect()
                    autoRepairConnection = nil
                end
                return
            end
            
            if tick() - lastRepairTime >= 0.1 then
                task.spawn(function()
                    pcall(performRepair)
                end)
            end
        end)
    else
        isRepairing = false
    end
end

LocalPlayer.CharacterAdded:Connect(function(character)
    task.wait(1)
    
    stunCooldowns = {}
    lastShoveTime = 0
    lastAttackTime = 0
    
    if killAuraToggled or shoveAuraToggled then
        observerOnline = false
        if killAuraConnection then
            killAuraConnection:Disconnect()
            killAuraConnection = nil
        end
        task.wait(0.1)
        createHitBox()
    end
    
    raycastParams.FilterDescendantsInstances = {character}
    params.FilterDescendantsInstances = {character}
    
    if not killbrickEnabled then
        toggleKillbrick(false)
    end
end)

-- Cleanup on character death/respawn
task.spawn(function()
    while true do
        task.wait(5)
        local currentTime = tick()
        for zombieId, lastTime in pairs(stunCooldowns) do
            if currentTime - lastTime > 10 then
                stunCooldowns[zombieId] = nil
            end
        end
    end
end)

-- Headless Aimbot
local p = game:GetService("Players")
local r = game:GetService("RunService")
local l = p.LocalPlayer
local c = workspace.CurrentCamera
local g = l:WaitForChild("PlayerGui"):FindFirstChild("HorsemanLockOn") or Instance.new("ScreenGui")

g.Name = "HorsemanLockOn"
g.ResetOnSpawn = false
g.Parent = l:WaitForChild("PlayerGui")

local aimbotEnabled = false
local aimbotInternalToggle = false
local aimbotPrediction = 0.1
local aimbotBoss = nil
local aimbotBossFinderConnection = nil
local aimbotRenderConnection = nil

if not g:FindFirstChild("MainFrame") then
    local f = Instance.new("Frame")
    f.Name = "MainFrame"
    f.Parent = g
    f.Size = UDim2.new(0, 200, 0, 120)
    f.Position = UDim2.new(0, 50, 0, 150)
    f.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    f.BackgroundTransparency = 0.3
    f.Active = true
    f.Draggable = true
    f.Visible = false

    local u = Instance.new("UICorner")
    u.CornerRadius = UDim.new(0, 12)
    u.Parent = f

    local t = Instance.new("TextLabel")
    t.Parent = f
    t.Size = UDim2.new(1, 0, 0, 30)
    t.Text = "Headless Horseman Lock-On"
    t.BackgroundTransparency = 1
    t.TextColor3 = Color3.new(1, 1, 1)
    t.TextScaled = true

    local b = Instance.new("TextButton")
    b.Name = "Toggle"
    b.Parent = f
    b.Size = UDim2.new(0, 80, 0, 30)
    b.Position = UDim2.new(0, 10, 0, 40)
    b.Text = "OFF"
    b.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    b.TextColor3 = Color3.new(1, 1, 1)
    b.TextScaled = true

    local x = Instance.new("UICorner")
    x.CornerRadius = UDim.new(0, 8)
    x.Parent = b

    local d = Instance.new("TextBox")
    d.Name = "Prediction"
    d.Parent = f
    d.Size = UDim2.new(0, 180, 0, 30)
    d.Position = UDim2.new(0, 10, 0, 80)
    d.Text = "0.1"
    d.PlaceholderText = "Prediction"
    d.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    d.TextColor3 = Color3.new(1, 1, 1)
    d.ClearTextOnFocus = false
    d.TextScaled = true

    local y = Instance.new("UICorner")
    y.CornerRadius = UDim.new(0, 8)
    y.Parent = d
end

local f = g.MainFrame
local b = f.Toggle
local d = f.Prediction

b.MouseButton1Click:Connect(function()
    aimbotInternalToggle = not aimbotInternalToggle
    b.Text = aimbotInternalToggle and "ON" or "OFF"
    b.BackgroundColor3 = aimbotInternalToggle and Color3.fromRGB(0, 150, 0) or Color3.fromRGB(40, 40, 40)
end)

d.FocusLost:Connect(function()
    local n = tonumber(d.Text)
    if n then aimbotPrediction = n end
end)

local function startBossFinder()
    if aimbotBossFinderConnection then
        task.cancel(aimbotBossFinderConnection)
    end
    aimbotBossFinderConnection = task.spawn(function()
        while aimbotEnabled do
            task.wait(2)
            if aimbotInternalToggle then
                local s = workspace:FindFirstChild("Sleepy Hollow")
                local m = s and s:FindFirstChild("Modes")
                local w = m and m:FindFirstChild("Boss")
                local k = w and w:FindFirstChild("HeadlessHorsemanBoss")
                aimbotBoss = k and k:FindFirstChild("HeadlessHorseman")
            else
                aimbotBoss = nil
            end
        end
        aimbotBoss = nil
    end)
end

local function startRenderStepped()
    if aimbotRenderConnection then
        aimbotRenderConnection:Disconnect()
    end
    aimbotRenderConnection = r.RenderStepped:Connect(function()
        if aimbotEnabled and aimbotInternalToggle and aimbotBoss and aimbotBoss.Parent then
            local e = aimbotBoss:FindFirstChild("Torso") or aimbotBoss:FindFirstChild("UpperTorso")
            if e then
                local q = e.Position + e.Velocity * aimbotPrediction
                c.CFrame = CFrame.new(c.CFrame.Position, q)
            end
        end
    end)
end

local function toggleAimbot(enabled)
    aimbotEnabled = enabled
    f.Visible = enabled
    
    if enabled then
        startBossFinder()
        startRenderStepped()
    else
        aimbotInternalToggle = false
        b.Text = "OFF"
        b.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
        aimbotBoss = nil
        if aimbotBossFinderConnection then
            task.cancel(aimbotBossFinderConnection)
            aimbotBossFinderConnection = nil
        end
        if aimbotRenderConnection then
            aimbotRenderConnection:Disconnect()
            aimbotRenderConnection = nil
        end
    end
end

-- GUI Creation
local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/SiriusSoftwareLtd/Rayfield/main/source.lua'))()

if not Rayfield then
    warn("Failed to load Rayfield library")
    return
end

local Window = Rayfield:CreateWindow({
    Name = "Chaos Hub",
    Icon = 0,
    LoadingTitle = "Chaos",
    LoadingSubtitle = "by Chaos Hub",
    Theme = "Ocean",
    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false,
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "G&B Hub"
    },
    Discord = {
        Enabled = true,
        Invite = "",
        RememberJoins = true
    }
})

local Tab = Window:CreateTab("Main", "album")
local Section = Tab:CreateSection("Main Functions")

local esp_Tab = Window:CreateTab("ESP", "target")
local esp_Section = esp_Tab:CreateSection("ESP Functions")

local player_Tab = Window:CreateTab("Player", "person-standing")
local player_Section = player_Tab:CreateSection("Aux. Player Functions")

local misc_Tab = Window:CreateTab("Misc", "settings")
local misc_Section = misc_Tab:CreateSection("Miscellaneous Functions")

local aimbot_Tab = Window:CreateTab("Aimbot", "crosshair")
local aimbot_Section = aimbot_Tab:CreateSection("Headless Horseman Aimbot")

-- Aimbot Tab
aimbot_Tab:CreateToggle({
    Name = "Headless Aimbot By Refs",
    CurrentValue = false,
    Flag = "HeadlessAimbot", 
    Callback = function(Value)
        toggleAimbot(Value)
    end
})

-- Main Tab
Tab:CreateToggle({
    Name = "WalkSpeed Freeze",
    CurrentValue = false,
    Flag = "WalkSpeed", 
    Callback = function(Value)
        walkSpeedToggled = Value
        changeWalkSpeed(walkSpeedValue, walkSpeedToggled)
    end
})

Tab:CreateInput({
   Name = "WalkSpeed",
   CurrentValue = "16",
   PlaceholderText = "WalkSpeed",
   RemoveTextAfterFocusLost = false,
   Flag = "Input1",
   Callback = function(Value)
       local val = tonumber(Value)
       if val then
           walkSpeedValue = val
           changeWalkSpeed(val, walkSpeedToggled)
       end
   end
})

-- Kill Aura & Shove Aura Toggles (Fixed callbacks)
Tab:CreateToggle({
    Name = "Kill Aura",
    CurrentValue = false,
    Flag = "KillAura", 
    Callback = function(Value)
        killAuraToggled = Value
        if Value then
            task.wait(0.1)
            createHitBox()
            if autoFaceToggled then
                startAutoFace()
            end
        else
            if not shoveAuraToggled then
                if killAuraConnection then
                    killAuraConnection:Disconnect()
                    killAuraConnection = nil
                end
                observerOnline = false
                isDead = false
                
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local hitbox = LocalPlayer.Character.HumanoidRootPart:FindFirstChild("Hitbox")
                    if hitbox then
                        hitbox:Destroy()
                    end
                end
            end
            if not shoveAuraToggled and autoFaceToggled then
                stopAutoFace()
            end
        end
    end
})

Tab:CreateToggle({
    Name = "Shove Aura",
    CurrentValue = false,
    Flag = "ShoveAura", 
    Callback = function(Value)
        shoveAuraToggled = Value
        if Value then
            task.wait(0.1)
            createHitBox()
            if autoFaceToggled then
                startAutoFace()
            end
        else
            if not killAuraToggled then
                if killAuraConnection then
                    killAuraConnection:Disconnect()
                    killAuraConnection = nil
                end
                observerOnline = false
                isDead = false
                
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local hitbox = LocalPlayer.Character.HumanoidRootPart:FindFirstChild("Hitbox")
                    if hitbox then
                        hitbox:Destroy()
                    end
                end
            end
            if not killAuraToggled and autoFaceToggled then
                stopAutoFace()
            end
        end
    end
})

Tab:CreateToggle({
    Name = "Auto Face Zombies",
    CurrentValue = false,
    Flag = "AutoFace", 
    Callback = function(Value)
        autoFaceToggled = Value
        if Value and (killAuraToggled or shoveAuraToggled) then
            startAutoFace()
        else
            stopAutoFace()
        end
    end
})

Tab:CreateSlider({
   Name = "Shove Radius",
   Range = {1, 15},
   Increment = 1,
   Suffix = " studs",
   CurrentValue = shoveRadius,
   Flag = "ShoveRadiusSlider",
   Callback = function(Value)
        setShoveRadius(Value)
   end
})

Tab:CreateSlider({
   Name = "Max Shove Per Cycle",
   Range = {1, 20},
   Increment = 1,
   Suffix = " zombies",
   CurrentValue = maxShovePerCycle,
   Flag = "MaxShoveSlider",
   Callback = function(Value)
        setMaxShovePerCycle(Value)
   end
})

Tab:CreateSlider({
   Name = "Max Kill Per Cycle",
   Range = {1, 20},
   Increment = 1,
   Suffix = " zombies",
   CurrentValue = maxKillPerCycle,
   Flag = "MaxKillSlider",
   Callback = function(Value)
        setMaxKillPerCycle(Value)
   end
})

Tab:CreateToggle({
    Name = "Head Lock",
    CurrentValue = false,
    Flag = "HeadLock", 
    Callback = function(Value)
        changeBayonet(Value)
        changeMelee(Value)
    end
})

Tab:CreateButton({
    Name = "Lights On (Saint Petersburg)",
    Callback = function()
        pcall(onLights)
    end
})

Tab:CreateToggle({
    Name = "Auto Play",
    CurrentValue = false,
    Flag = "auto_play", 
    Callback = function(Value)
        autoplay = Value
        if Value then
            startAutoPlay()
        else
            if autoPlayConnection then
                autoPlayConnection:Disconnect()
                autoPlayConnection = nil
            end
            if autoStartConnection then
                task.cancel(autoStartConnection)
                autoStartConnection = nil
            end
            if colorCheckConnection then
                colorCheckConnection:Disconnect()
                colorCheckConnection = nil
            end
            for _, conn in pairs(equippedConnections) do
                if conn then conn:Disconnect() end
            end
            equippedConnections = {}
            changeMusicGUIColor(false)
            lastUpdateAccuracy = 0
        end
    end
})

Tab:CreateToggle({
    Name = "Auto Repair",
    CurrentValue = false,
    Flag = "AutoRepair",
    Callback = function(Value)
        autoRepair(Value)
    end
})

Tab:CreateToggle({
    Name = "Auto Equip Hammer",
    CurrentValue = false,
    Flag = "AutoEquipHammer",
    Callback = function(Value)
        autoEquipHammerToggled = Value
    end
})

Tab:CreateToggle({
    Name = "Zombie Hitbox Expander",
    CurrentValue = false,
    Flag = "HitboxExpander",
    Callback = function(Value)
        toggleHitboxExpander(Value)
    end
})

Tab:CreateSlider({
   Name = "Zombie Hitbox Size",
   Range = {1, 30},
   Increment = 1,
   Suffix = " studs",
   CurrentValue = hitboxSize,
   Flag = "HitboxSizeSlider",
   Callback = function(Value)
        setHitboxSize(Value)
   end
})

-- Player Tab (Fixed: Separate ESP)
player_Tab:CreateToggle({
    Name = "Medic Player ESP",
    CurrentValue = false,
    Flag = "medic_esp", 
    Callback = function(Value)
        espMedicToggled = Value
        if Value or espInfectionToggled then  -- Start loop if any on
            checkPlayersLife()
        end
    end
})

player_Tab:CreateToggle({
    Name = "Father Infection ESP",
    CurrentValue = false,
    Flag = "father_infection", 
    Callback = function(Value)
        espInfectionToggled = Value
        if Value or espMedicToggled then
            checkPlayersLife()
        end
    end
})

-- ESP Tab (Fixed: espCuToggled)
esp_Tab:CreateToggle({
    Name = "ESP Runner",
    CurrentValue = false,
    Flag = "ESP_1",
    Callback = function(Value)
        espRToggled = Value
    end
})

esp_Tab:CreateToggle({
    Name = "ESP Bomber",
    CurrentValue = false,
    Flag = "ESP_2",
    Callback = function(Value)
        espBToggled = Value
    end
})

esp_Tab:CreateToggle({
    Name = "ESP Igniter",
    CurrentValue = false,
    Flag = "ESP_3",
    Callback = function(Value)
        espIToggled = Value
    end
})

esp_Tab:CreateToggle({
    Name = "ESP Cuirassier",
    CurrentValue = false,
    Flag = "ESP_4",
    Callback = function(Value)
        espCuToggled = Value
    end
})

esp_Tab:CreateToggle({
    Name = "ESP Boss (Fixed)",
    CurrentValue = false,
    Flag = "ESP_5",
    Callback = function(Value)
        espBossToggled = Value
        updateBossESP()
    end
})

-- Misc Tab
misc_Tab:CreateToggle({
    Name = "Fullbright",
    CurrentValue = false,
    Flag = "Fullbright",
    Callback = function(Value)
        toggleFullbright(Value)
    end
})

misc_Tab:CreateToggle({
    Name = "Killbrick Protection",
    CurrentValue = false,
    Flag = "KillbrickProtection",
    Callback = function(Value)
        toggleKillbrick(not Value)
    end
})

misc_Section = misc_Tab:CreateSection("GitHub Scripts")

-- Anti-Cheat Bypass Button
misc_Tab:CreateButton({
    Name = "Load Anti-Cheat Bypass",
    Callback = function()
        local success, result = pcall(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/cjbbth1-crypto/Anti-cheat-bypass/refs/heads/main/Anti-cheat-bypass"))()
        end)
        
        if success then
            Rayfield:Notify({
                Title = "Success",
                Content = "Anti-Cheat Bypass loaded successfully!",
                Duration = 3,
                Image = "check"
            })
        else
            Rayfield:Notify({
                Title = "Error",
                Content = "Failed to load Anti-Cheat Bypass: " .. tostring(result),
                Duration = 5,
                Image = "alert-triangle"
            })
        end
    end
})

-- Animation Fun Button
misc_Tab:CreateButton({
    Name = "Load Animation Fun",
    Callback = function()
        local success, result = pcall(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/cjbbth1-crypto/Animation-fun/refs/heads/main/Animation%20fun"))()
        end)
        
        if success then
            Rayfield:Notify({
                Title = "Success",
                Content = "Animation Fun loaded successfully!",
                Duration = 3,
                Image = "check"
            })
        else
            Rayfield:Notify({
                Title = "Error",
                Content = "Failed to load Animation Fun: " .. tostring(result),
                Duration = 5,
                Image = "alert-triangle"
            })
        end
    end
})

end)

if not success then
    warn("Script error: " .. tostring(errorMsg))
end
