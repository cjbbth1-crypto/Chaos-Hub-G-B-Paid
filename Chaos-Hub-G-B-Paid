local success, errorMsg = pcall(function()

local LocalPlayer = game:GetService("Players").LocalPlayer
local RunService = game:GetService("RunService")

-- ESP Variables
espRToggled = false
espBToggled = false
espIToggled = false
espCuToogled = false
espBossToggled = false

local bossFolder = nil
pcall(function()
    bossFolder = workspace:WaitForChild("Sleepy Hollow", 10).Modes.Boss.HeadlessHorsemanBoss
end)

if bossFolder then
    bossFolder.ChildAdded:Connect(function(child)
        if espBossToggled then
            local Highlight = Instance.new("Highlight")
            Highlight.Parent = child
            Highlight.Adornee = child
            Highlight.FillColor = Color3.fromRGB(255, 0, 0)
        end
    end)

    for _, child in pairs(bossFolder:GetChildren()) do
        if espBossToggled then
            local Highlight = Instance.new("Highlight")
            Highlight.Parent = child
            Highlight.Adornee = child
            Highlight.FillColor = Color3.fromRGB(255, 0, 0)
        end
    end
end

workspace.Camera.ChildAdded:Connect(function(child)
    if child.Name == "m_Zombie" then
        local Origin = child:WaitForChild("Orig", 5)
        if Origin and Origin.Value ~= nil then
            local zombie = Origin.Value:FindFirstChild("Zombie")
            if not zombie then return end
            
            if espRToggled and zombie.WalkSpeed > 16 then
                local Highlight = Instance.new("Highlight")
                Highlight.Parent = child
                Highlight.Adornee = child
            end
            
            if espBToggled and child:FindFirstChild("Barrel") ~= nil then
                local Highlight = Instance.new("Highlight")
                Highlight.Parent = child
                Highlight.Adornee = child
                Highlight.FillColor = Color3.fromRGB(65,105,225)
            end
            
            if espIToggled and child:FindFirstChild("Whale Oil Lantern") ~= nil then
                local Highlight = Instance.new("Highlight")
                Highlight.Parent = child
                Highlight.Adornee = child
                Highlight.FillColor = Color3.fromRGB(255,255,51)
            end
            
            if espCuToogled and child:FindFirstChild("Sword") ~= nil then
                local Highlight = Instance.new("Highlight")
                Highlight.Parent = child
                Highlight.Adornee = child
                Highlight.FillColor = Color3.fromRGB(65,105,225)  
            end
        end
    end
end)

-- ESP Players
espLifeToggled = false

function checkPlayersLife()
    if espLifeToggled == false then
        local Players = workspace.Players:GetChildren()
        for i, player in pairs(Players) do
            if player:FindFirstChild("Highlight") then
                player.Highlight:Destroy()
            end
        end
    end

    while espLifeToggled do
        local Players = workspace.Players:GetChildren()
        for i, player in pairs(Players) do
            local humanoid = player:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health < 60 and player.Name ~= LocalPlayer.Name and 
               (LocalPlayer.Backpack:FindFirstChild("Medical Supplies") or 
               (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Medical Supplies"))) then
                if not player:FindFirstChild("Highlight") then
                    local Highlight = Instance.new("Highlight")
                    Highlight.Parent = player
                    Highlight.Adornee = player
                    Highlight.FillColor = Color3.fromRGB(255, 169, 108)
                    Highlight.FillTransparency = 0.8
                    Highlight.OutlineColor = Color3.fromRGB(255, 206, 108)
                    Highlight.OutlineTransparency = 0.2
                end
            else
                if player:FindFirstChild("Highlight") then
                    player.Highlight:Destroy()
                end
            end

            if LocalPlayer.Backpack:FindFirstChild("Mercy") or 
               (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Mercy")) then
                local userStates = player:FindFirstChild("UserStates")
                if userStates and userStates:FindFirstChild("Infected") then
                    if userStates.Infected.Value > 10 then
                        if userStates.Infected.Value > 89 then
                            local Highlight = player:FindFirstChild("Highlight") or Instance.new("Highlight")
                            Highlight.Parent = player
                            Highlight.Adornee = player
                            Highlight.FillColor = Color3.fromRGB(178,34,34)
                        else
                            if not player:FindFirstChild("Highlight") then
                                local Highlight = Instance.new("Highlight")
                                Highlight.Parent = player
                                Highlight.Adornee = player
                                Highlight.FillColor = Color3.fromRGB(255, 169, 108)
                                Highlight.FillTransparency = 0.8
                                Highlight.OutlineColor = Color3.fromRGB(255, 206, 108)
                                Highlight.OutlineTransparency = 0.2
                            end
                        end
                    elseif player:FindFirstChild("Highlight") and userStates.Infected.Value == 0 then
                        player.Highlight:Destroy()
                    end
                end
            end
        end
        task.wait(2.0)
    end
end

toolEquip = true

-- OPTIMIZED Kill Aura & Shove Aura (FIXED)
observerOnline = false
killAuraToggled = false
killBomberToggled = false
shoveAuraToggled = false
isDead = false
killAuraConnection = nil

shoveRadius = 8
maxShovePerCycle = 10
local stunCooldowns = {}
local lastShoveTime = 0
local killAuraRadius = 13
local killAuraMaxAttacksPerFrame = 10
local killAuraHitsPerZombie = 2
local lastAttackTime = 0
local attackThrottle = 0.01

local zombiesFolder = workspace:WaitForChild("Zombies")

local raycastParams = RaycastParams.new()
raycastParams.FilterType = Enum.RaycastFilterType.Exclude

local params = OverlapParams.new()
params.FilterType = Enum.RaycastFilterType.Include
params.FilterDescendantsInstances = {zombiesFolder}

local function updateFilters()
    if LocalPlayer.Character then
        raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
    end
end

updateFilters()

function getEquippedWeapon()
    if not LocalPlayer.Character then return nil end
    
    for _, child in pairs(LocalPlayer.Character:GetChildren()) do
        if child:IsA("Tool") and (child:FindFirstChild("RemoteEvent") or child:FindFirstChild("Remote")) then
            return child
        end
    end
    
    return nil
end

function canWeaponShove(weapon)
    if not weapon then return false end
    
    local shoveWeapons = {"Pickaxe", "Axe", "Carbine", "Navy Pistol"}
    
    for _, shoveWeapon in pairs(shoveWeapons) do
        if weapon.Name:lower():find(shoveWeapon:lower()) then
            return true
        end
    end
    
    return weapon:GetAttribute("CanShove") == true
end

function shoveAttack(weapon, hit, hitPart)
    if not weapon or not hit then return end
    
    local currentTime = tick()
    stunCooldowns[tostring(hit)] = currentTime
    
    local remoteEvent = weapon:FindFirstChild("RemoteEvent") or weapon:FindFirstChild("Remote")
    if not remoteEvent then return end
    
    task.spawn(function()
        pcall(function()
            remoteEvent:FireServer("FeedbackStun", hit, hitPart.Position)
            
            local wName = weapon.Name:lower()
            if wName:find("axe") then
                remoteEvent:FireServer("BraceBlock")
                remoteEvent:FireServer("StopBraceBlock")
                remoteEvent:FireServer("FeedbackStunObject", hit, hitPart.Position)
            elseif wName:find("pickaxe") then
                remoteEvent:FireServer("Swing", "Shove")
                remoteEvent:FireServer("FeedbackStun", hit, hitPart.Position)
            elseif wName:find("carbine") or wName:find("navy pistol") then
                remoteEvent:FireServer("Shove")
            end
        end)
    end)
end

local zombiePositionCache = {}
local zombieVelocityCache = {}
local playerPositionCache = nil
local playerVelocityCache = Vector3.zero
local lastCleanupTime = 0
local lastHealthCheckTime = 0
local consecutiveErrors = 0

function detectEnemy(hitbox, hrp)
    if killAuraConnection then
        killAuraConnection:Disconnect()
    end
    
    killAuraConnection = RunService.Heartbeat:Connect(function()
        if not killAuraToggled and not shoveAuraToggled then
            isDead = false
            observerOnline = false
            consecutiveErrors = 0
            if killAuraConnection then
                killAuraConnection:Disconnect()
                killAuraConnection = nil
            end
            return
        end

        if not LocalPlayer.Character or not hitbox or not hitbox.Parent or not hrp or not hrp.Parent then
            consecutiveErrors = consecutiveErrors + 1
            if consecutiveErrors > 150 then
                consecutiveErrors = 0
                observerOnline = false
                if killAuraToggled or shoveAuraToggled then
                    task.delay(0.02, function()
                        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                            createHitBox()
                        end
                    end)
                end
            end
            return
        end
        
        consecutiveErrors = 0
        local currentTime = tick()
        
        if currentTime - lastHealthCheckTime > 2 then
            if killAuraToggled or shoveAuraToggled then
                if not hitbox or not hitbox.Parent then
                    observerOnline = false
                    createHitBox()
                    return
                end
            end
            lastHealthCheckTime = currentTime
        end
        
        if killAuraToggled and currentTime - lastCleanupTime > 3 then
            pcall(function()
                local activeZombies = {}
                for _, z in pairs(zombiesFolder:GetChildren()) do
                    activeZombies[tostring(z)] = true
                end
                
                for zombieId in pairs(zombiePositionCache) do
                    if not activeZombies[zombieId] then
                        zombiePositionCache[zombieId] = nil
                        zombieVelocityCache[zombieId] = nil
                    end
                end
            end)
            lastCleanupTime = currentTime
        end
        
        if currentTime - lastShoveTime < 0.05 then return end

        local zombiesToShove = {}
        local zombiesToAttack = {}
        local equippedWeapon = getEquippedWeapon()
        
        if killAuraToggled and not equippedWeapon then 
            return 
        end
        
        local playerCFrame = hrp.CFrame
        local playerPos = playerCFrame.Position
        
        if killAuraToggled then
            if playerPositionCache then
                playerVelocityCache = (playerPos - playerPositionCache) / 0.03
            end
            playerPositionCache = playerPos
        end

        local success = pcall(function()
            if not zombiesFolder then return end

            local parts = workspace:GetPartsInPart(hitbox, params)
            local processedZombies = {}
            local maxZombiesPerFrame = 20

            for i, part in ipairs(parts) do
                if i > maxZombiesPerFrame then break end
                local serverZombie = part.Parent
                if not serverZombie or not serverZombie.Parent then continue end
                
                local zombieId = tostring(serverZombie)
                if processedZombies[zombieId] then continue end
                processedZombies[zombieId] = true
                
                local zombie = serverZombie:FindFirstChild("Zombie")
                if not zombie then continue end
                
                local head = serverZombie:FindFirstChild("Head")
                local zombieHRP = serverZombie:FindFirstChild("HumanoidRootPart")
                
                if not head or not zombieHRP then continue end

                local zombieCFrame = zombieHRP.CFrame
                local zombiePos = zombieCFrame.Position
                
                local zombieVelocity = Vector3.zero
                if killAuraToggled then
                    local lastPos = zombiePositionCache[zombieId]
                    
                    if lastPos then
                        zombieVelocity = (zombiePos - lastPos) / 0.03
                        zombieVelocityCache[zombieId] = zombieVelocity
                    else
                        zombieVelocity = zombieVelocityCache[zombieId] or Vector3.zero
                    end
                    
                    zombiePositionCache[zombieId] = zombiePos
                end
                
                local predictedPlayerPos = playerPos
                local predictedZombiePos = zombiePos
                
                if killAuraToggled then
                    local pingCompensation = 0.15
                    predictedPlayerPos = playerPos + (playerVelocityCache * pingCompensation)
                    predictedZombiePos = zombiePos + (zombieVelocity * pingCompensation)
                end
                
                local toZombie = predictedZombiePos - predictedPlayerPos
                local distance = toZombie.Magnitude
                
                local maxRadius = math.max(shoveRadius, killAuraRadius) + 5
                if distance > maxRadius then continue end
                
                if shoveAuraToggled and equippedWeapon and canWeaponShove(equippedWeapon) and distance <= shoveRadius then
                    if not stunCooldowns[zombieId] or currentTime - stunCooldowns[zombieId] >= 1.0 then
                        table.insert(zombiesToShove, {
                            hit = serverZombie, 
                            head = head,
                            zombie = zombie, 
                            priority = zombie.WalkSpeed > 16 and 1 or 2,
                            distance = distance,
                            serverPos = zombiePos
                        })
                    end
                end
                
                if killAuraToggled and distance <= killAuraRadius then
                    local willBeShoved = false
                    
                    if shoveAuraToggled and equippedWeapon and canWeaponShove(equippedWeapon) and distance <= shoveRadius then
                        if not stunCooldowns[zombieId] or currentTime - stunCooldowns[zombieId] >= 1.0 then
                            willBeShoved = true
                        end
                    end
                    
                    if not willBeShoved then
                        local calc = toZombie
                        if calc:Dot(calc) > 1 then
                            calc = calc.Unit
                        end
                        
                        -- FIXED: Bomber detection without WalkSpeed check to match ESP
                        local isBomber = serverZombie:FindFirstChild("Barrel") ~= nil
                        
                        table.insert(zombiesToAttack, {
                            hit = serverZombie,
                            head = head,
                            zombie = zombie,
                            calc = calc,
                            serverPos = predictedZombiePos,
                            distance = distance,
                            rawDistance = (zombiePos - playerPos).Magnitude,
                            isBomber = isBomber
                        })
                    end
                end
            end
        end)
        
        if not success then
            consecutiveErrors = consecutiveErrors + 1
            if consecutiveErrors > 300 then
                consecutiveErrors = 0
                observerOnline = false
                if killAuraToggled or shoveAuraToggled then
                    task.delay(0.02, function()
                        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                            createHitBox()
                        end
                    end)
                end
            end
            return
        end

        if #zombiesToShove > 0 and equippedWeapon and canWeaponShove(equippedWeapon) and toolEquip then
            table.sort(zombiesToShove, function(a, b) 
                if a.priority ~= b.priority then
                    return a.priority < b.priority
                end
                return a.distance < b.distance
            end)
            
            local shoveCount = math.min(#zombiesToShove, maxShovePerCycle)
            for i = 1, shoveCount do
                local z = zombiesToShove[i]
                pcall(function()
                    shoveAttack(equippedWeapon, z.hit, z.head)
                end)
            end
            
            lastShoveTime = currentTime
            return
        end
        
        if killAuraToggled and #zombiesToAttack > 0 and equippedWeapon and toolEquip and (currentTime - lastAttackTime > attackThrottle) then
            table.sort(zombiesToAttack, function(a, b) return a.rawDistance < b.rawDistance end)
            
            local attackCount = 0
            
            for _, zData in pairs(zombiesToAttack) do
                if attackCount >= killAuraMaxAttacksPerFrame then break end
                
                -- FIXED: Skip bombers if not toggled
                if zData.isBomber and not killBomberToggled then
                    continue
                end
                
                for hitAttempt = 1, killAuraHitsPerZombie do
                    if attackCount >= killAuraMaxAttacksPerFrame then break end
                    
                    local remoteEvent = equippedWeapon:FindFirstChild("RemoteEvent") or equippedWeapon:FindFirstChild("Remote")
                    if remoteEvent then
                        local attackSuccess = pcall(function()
                            remoteEvent:FireServer("Swing", "Thrust")
                            remoteEvent:FireServer("HitZombie", zData.hit, zData.serverPos, true, zData.calc * 25, "Head", Vector3.new(0,1,0))
                        end)
                        
                        if attackSuccess then
                            attackCount = attackCount + 1
                        end
                    end
                end
            end
            lastAttackTime = currentTime
        end
    end)
end

function setShoveRadius(newRadius)
    shoveRadius = newRadius
    
    if (killAuraToggled or shoveAuraToggled) and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        observerOnline = false
        if killAuraConnection then
            killAuraConnection:Disconnect()
            killAuraConnection = nil
        end
        
        local existingHitbox = LocalPlayer.Character.HumanoidRootPart:FindFirstChild("Hitbox")
        if existingHitbox then
            existingHitbox:Destroy()
        end
        
        task.wait(0.1)
        createHitBox()
    end
end

function setMaxShovePerCycle(newMax)
    maxShovePerCycle = newMax
end

function setKillAuraMaxAttacksPerFrame(newMax)
    killAuraMaxAttacksPerFrame = newMax
end

function createHitBox()
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end

    local torso = LocalPlayer.Character.HumanoidRootPart
    local existingHitbox = torso:FindFirstChild("Hitbox")
    
    local hitboxSize, hitboxOffset
    
    if shoveAuraToggled and not killAuraToggled then
        hitboxSize = Vector3.new(shoveRadius * 2, 6, shoveRadius * 2)
        hitboxOffset = CFrame.new(0, 0, -shoveRadius * 0.6)
    elseif killAuraToggled and not shoveAuraToggled then
        hitboxSize = Vector3.new(killAuraRadius * 2, 7, killAuraRadius * 2)
        hitboxOffset = CFrame.new(0, 0, -killAuraRadius * 0.6)
    else
        local maxRadius = math.max(shoveRadius, killAuraRadius)
        hitboxSize = Vector3.new(maxRadius * 2, 7, maxRadius * 2)
        hitboxOffset = CFrame.new(0, 0, -maxRadius * 0.6)
    end
    
    if existingHitbox then
        existingHitbox.Size = hitboxSize
        existingHitbox.CFrame = torso.CFrame * hitboxOffset
        
        if not observerOnline then
            observerOnline = true
            detectEnemy(existingHitbox, torso)
        end
        return true
    else
        local hitbox = Instance.new("Part")
        hitbox.Name = "Hitbox"
        hitbox.Parent = torso
        hitbox.Anchored = false
        hitbox.Massless = true
        hitbox.CanCollide = false
        hitbox.CanTouch = false
        hitbox.Transparency = 1
        hitbox.Size = hitboxSize
        hitbox.CFrame = torso.CFrame * hitboxOffset

        local weld = Instance.new("WeldConstraint")
        weld.Parent = torso
        weld.Part0 = hitbox
        weld.Part1 = torso

        if not observerOnline then
            observerOnline = true
            detectEnemy(hitbox, torso)
        end

        return true
    end
end

function onLights()
    local ligthPost = workspace:FindFirstChild("Saint Petersburg")
    if not ligthPost then return end
    
    local modes = ligthPost:FindFirstChild("Modes")
    if not modes then return end
    
    local holdout = modes:FindFirstChild("Holdout")
    if not holdout then return end
    
    local lampPosts = holdout:FindFirstChild("LampPosts")
    if not lampPosts then return end
    
    for _, part in pairs(lampPosts:GetChildren()) do
        local metal = part:FindFirstChild("Metal")
        if metal and metal:FindFirstChild("Light") then
            metal.Light.PointLight.Enabled = true
            metal.Light.Visible = true
        end
    end
end

local connection = nil

local function changeWalkSpeed(newValue, walkSpeedToggled)
    local workPlayer = LocalPlayer.Character
    if workPlayer and workPlayer:FindFirstChild("Humanoid") then
        workPlayer.Humanoid.WalkSpeed = newValue
        if walkSpeedToggled then
            if connection then connection:Disconnect() end
            connection = workPlayer.Humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function() 
                workPlayer.Humanoid.WalkSpeed = newValue 
            end)
        else
            if connection then
                connection:Disconnect()
                connection = nil
            end
        end
    end
end

walkSpeedToggled = false
walkSpeedValue = 16

workspace.Players.ChildAdded:Connect(function(child)
    changeWalkSpeed(walkSpeedValue, walkSpeedToggled)
end)

local namecall
autoplay = false

namecall = hookmetamethod(game, "__namecall", function(self, ...)
    local args = {...}
    local method = getnamecallmethod():lower()

    if not checkcaller() and self.Name == "RemoteEvent" and method == "fireserver" then
        if autoplay and args[1] == "UpdateAccuracy" then
            args[2] = 100
            return namecall(self, unpack(args))
        end
    end
    return namecall(self, ...)
end)

-- Bayonet & Melee Head Lock
local FlintLock = require(game:GetService("ReplicatedStorage").Modules.Weapons:FindFirstChild("Flintlock"))
local MeleeBase = require(game:GetService("ReplicatedStorage").Modules.Weapons:FindFirstChild("MeleeBase"))

local originBayonet = FlintLock.BayonetHitCheck
local originMelee = MeleeBase.MeleeHitCheck

local customBayonet = {}
function customBayonet.BayonetHitCheck(p115, p116, p117, p118, p119)
    local v120 = workspace:Raycast(p116, p117, p118)
    if v120 and v120.Instance.Parent.Name == "m_Zombie" then
        
        local v123 = v120.Instance.Parent:FindFirstChild("Orig")
        if v123 then
            local Head = v120.Instance.Parent:FindFirstChild("Head")
            if Head then
                p115.remoteEvent:FireServer("Bayonet_HitZombie", v123.Value, Head.CFrame.Position, true, "Head")
            end
        end
        return 2
    end
    return 0
end

local customMelee = {}
function customMelee.MeleeHitCheck(p100, p101, p102, p103, p104, p105)
    local v106 = workspace:Raycast(p101, p102, p103)
    if v106 and v106.Instance.Parent.Name == "m_Zombie" then
        
        local v109 = v106.Instance.Parent:FindFirstChild("Orig")
        if v109 then
            if not p104[v109] or p104[v109] < (p100.Stats.MaxHits or 3) then
                if not p105 then
                    local Head = v106.Instance.Parent:FindFirstChild("Head")
                    if Head then
                        local u112 = v109.Value
                        local v113 = Head.CFrame.Position - p101
                        if v113:Dot(v113) > 1 then
                            v113 = v113.Unit
                        end
                        local v114 = v113 * 25
                        p100.remoteEvent:FireServer("HitZombie", u112, Head.CFrame.Position, true, v114, "Head", v106.Normal)
                    end
                end
                
                if p104[v109] then
                    p104[v109] = p104[v109] + 1
                else
                    table.insert(p104, v109)
                    p104[v109] = 1
                end
            end
        end
        return 1
    end
    return 0
end

function changeBayonet(value)
    FlintLock.BayonetHitCheck = value and customBayonet.BayonetHitCheck or originBayonet
end

function changeMelee(value)
    MeleeBase.MeleeHitCheck = value and customMelee.MeleeHitCheck or originMelee
end

-- Working Zombie Hitbox Expander (Fixed)
local hitboxEnabled = false
local hitboxSize = 10
local zombieFolder = workspace:WaitForChild("Zombies")

local function addOuterHitbox(zombie)
    if not zombie or not zombie.Parent then return end
    local hrp = zombie:FindFirstChild("HumanoidRootPart")
    if hrp and not zombie:FindFirstChild("OuterHitbox") then
        pcall(function()
            local part = Instance.new("Part")
            part.Name = "OuterHitbox"
            part.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
            part.Transparency = 1
            part.Anchored = false
            part.CanCollide = false
            part.Massless = true
            part.CanTouch = true
            part.CFrame = hrp.CFrame
            part.Parent = zombie

            local weld = Instance.new("WeldConstraint")
            weld.Part0 = hrp
            weld.Part1 = part
            weld.Parent = part
        end)
    end
end

local function addHeadHitbox(zombie)
    if not zombie or not zombie.Parent then return end
    local head = zombie:FindFirstChild("Head")
    if head and not zombie:FindFirstChild("HeadHitbox") then
        pcall(function()
            local part = Instance.new("Part")
            part.Name = "HeadHitbox"
            part.Size = Vector3.new(hitboxSize/2, hitboxSize/2, hitboxSize/2)
            part.Transparency = 1
            part.Anchored = false
            part.CanCollide = false
            part.Massless = true
            part.CanTouch = true
            part.CFrame = head.CFrame
            part.Parent = zombie

            local weld = Instance.new("WeldConstraint")
            weld.Part0 = head
            weld.Part1 = part
            weld.Parent = part
        end)
    end
end

local function removeHitboxes(zombie)
    if not zombie then return end
    pcall(function()
        local outer = zombie:FindFirstChild("OuterHitbox")
        local head = zombie:FindFirstChild("HeadHitbox")
        if outer then outer:Destroy() end
        if head then head:Destroy() end
    end)
end

local function updateHitboxes(zombie)
    if not zombie then return end
    if hitboxEnabled then
        removeHitboxes(zombie)
        task.wait(0.05)
        addOuterHitbox(zombie)
        addHeadHitbox(zombie)
    else
        removeHitboxes(zombie)
    end
end

local function setHitboxSize(newSize)
    hitboxSize = newSize
    if hitboxEnabled then
        pcall(function()
            for _, zombie in pairs(zombieFolder:GetChildren()) do
                updateHitboxes(zombie)
            end
            for _, zombie in pairs(workspace.Camera:GetChildren()) do
                if zombie.Name == "m_Zombie" then
                    updateHitboxes(zombie)
                end
            end
        end)
    end
end

local function toggleHitboxExpander(enabled)
    hitboxEnabled = enabled
    
    pcall(function()
        for _, zombie in pairs(zombieFolder:GetChildren()) do
            updateHitboxes(zombie)
        end
        for _, zombie in pairs(workspace.Camera:GetChildren()) do
            if zombie.Name == "m_Zombie" then
                updateHitboxes(zombie)
            end
        end
    end)
end

-- Auto-apply to new zombies
zombieFolder.ChildAdded:Connect(function(zombie)
    if hitboxEnabled then
        task.wait(0.2)
        updateHitboxes(zombie)
    end
end)

workspace.Camera.ChildAdded:Connect(function(zombie)
    if zombie.Name == "m_Zombie" and hitboxEnabled then
        task.wait(0.2)
        updateHitboxes(zombie)
    end
end)

-- Fullbright
local Light = game:GetService("Lighting")
local fullbrightEnabled = false
local fullbrightConnection = nil
local originalLighting = {
    Ambient = Light.Ambient,
    ColorShift_Bottom = Light.ColorShift_Bottom,
    ColorShift_Top = Light.ColorShift_Top,
    OutdoorAmbient = Light.OutdoorAmbient,
    Brightness = Light.Brightness
}

local function doFullbright()
    if not fullbrightEnabled then return end
    Light.Ambient = Color3.new(1, 1, 1)
    Light.ColorShift_Bottom = Color3.new(1, 1, 1)
    Light.ColorShift_Top = Color3.new(1, 1, 1)
    Light.OutdoorAmbient = Color3.new(1, 1, 1)
    Light.Brightness = 2
end

local function restoreLighting()
    Light.Ambient = originalLighting.Ambient
    Light.ColorShift_Bottom = originalLighting.ColorShift_Bottom
    Light.ColorShift_Top = originalLighting.ColorShift_Top
    Light.OutdoorAmbient = originalLighting.OutdoorAmbient
    Light.Brightness = originalLighting.Brightness
end

local function toggleFullbright(enabled)
    fullbrightEnabled = enabled
    if fullbrightConnection then
        fullbrightConnection:Disconnect()
        fullbrightConnection = nil
    end
    
    if enabled then
        doFullbright()
        fullbrightConnection = Light.LightingChanged:Connect(doFullbright)
    else
        restoreLighting()
    end
end

-- Killbrick Protection
local killbrickEnabled = true
local killbrickConnection = nil

local function toggleKillbrick(enabled)
    killbrickEnabled = enabled
    if killbrickConnection then
        killbrickConnection:Disconnect()
        killbrickConnection = nil
    end
    
    if not enabled then
        killbrickConnection = RunService.Heartbeat:Connect(function()
            if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
            local parts = workspace:GetPartBoundsInRadius(LocalPlayer.Character.HumanoidRootPart.Position, 10)
            for _, part in ipairs(parts) do
                part.CanTouch = false
            end
        end)
    end
end

-- Auto Repair
local autoRepairToggled = false
local autoEquipHammerToggled = false
local autoRepairConnection = nil
local lastRepairTime = 0
local isRepairing = false

local function equipHammer()
    local hammer = LocalPlayer.Backpack:FindFirstChild("Hammer")
    if not hammer then return false end
    
    pcall(function()
        LocalPlayer.Character.Humanoid:EquipTool(hammer)
    end)
    
    task.wait(0.2)
    return LocalPlayer.Character:FindFirstChild("Hammer") ~= nil
end

local function performRepair()
    if isRepairing or not autoRepairToggled or not LocalPlayer.Character then return false end
    
    local currentTime = tick()
    if currentTime - lastRepairTime < 0.1 then return false end
    
    local hammerTool = LocalPlayer.Character:FindFirstChild("Hammer")
    
    if not hammerTool and autoEquipHammerToggled then
        if not equipHammer() then return false end
        hammerTool = LocalPlayer.Character:FindFirstChild("Hammer")
    end
    
    if not hammerTool then return false end
    
    isRepairing = true
    
    local remoteEvent = hammerTool:FindFirstChild("RemoteEvent")
    if not remoteEvent then
        isRepairing = false
        return false
    end
    
    local repairParams = RaycastParams.new()
    repairParams.IgnoreWater = true
    repairParams.FilterDescendantsInstances = {LocalPlayer.Character}
    repairParams.FilterType = Enum.RaycastFilterType.Exclude
    
    local head = LocalPlayer.Character:FindFirstChild("Head")
    if not head then
        isRepairing = false
        return false
    end
    
    local repaired = false
    pcall(function()
        local direction = workspace.CurrentCamera.CFrame.LookVector
        local raycast = workspace:Raycast(head.Position, direction * 8, repairParams)
        
        if raycast and raycast.Instance then
            local buildingHealth = raycast.Instance.Parent:FindFirstChild("BuildingHealth") or 
                                 raycast.Instance.Parent.Parent:FindFirstChild("BuildingHealth")
            local constructHealth = raycast.Instance:FindFirstChild("ConstructHealth")
            
            if buildingHealth or constructHealth then
                remoteEvent:FireServer("Repair", buildingHealth or constructHealth)
                lastRepairTime = currentTime
                repaired = true
            end
        end
    end)
    
    isRepairing = false
    return repaired
end

local function autoRepair(Value)
    autoRepairToggled = Value
    
    if autoRepairConnection then
        autoRepairConnection:Disconnect()
        autoRepairConnection = nil
    end
    
    if autoRepairToggled then
        isRepairing = false
        autoRepairConnection = RunService.Heartbeat:Connect(function()
            if not autoRepairToggled then
                if autoRepairConnection then
                    autoRepairConnection:Disconnect()
                    autoRepairConnection = nil
                end
                return
            end
            
            if tick() - lastRepairTime >= 0.1 then
                task.spawn(function()
                    pcall(performRepair)
                end)
            end
        end)
    else
        isRepairing = false
    end
end

-- Cleanup cooldowns
task.spawn(function()
    while true do
        task.wait(5)
        local currentTime = tick()
        for zombieId, lastTime in pairs(stunCooldowns) do
            if currentTime - lastTime > 10 then
                stunCooldowns[zombieId] = nil
            end
        end
    end
end)

-- Character respawn handler
LocalPlayer.CharacterAdded:Connect(function(character)
    task.wait(1)
    
    stunCooldowns = {}
    lastShoveTime = 0
    lastAttackTime = 0
    
    updateFilters()
    
    if killAuraToggled or shoveAuraToggled then
        observerOnline = false
        if killAuraConnection then
            killAuraConnection:Disconnect()
            killAuraConnection = nil
        end
        createHitBox()
    end
    
    if not killbrickEnabled then
        toggleKillbrick(false)
    end
end)

-- Headless Aimbot
local p = game:GetService("Players")
local r = game:GetService("RunService")
local l = p.LocalPlayer
local c = workspace.CurrentCamera
local g = l:WaitForChild("PlayerGui"):FindFirstChild("HorsemanLockOn") or Instance.new("ScreenGui")

g.Name = "HorsemanLockOn"
g.ResetOnSpawn = false
g.Parent = l:WaitForChild("PlayerGui")

local aimbotEnabled = false
local aimbotInternalToggle = false
local aimbotPrediction = 0.1
local aimbotBoss = nil
local aimbotBossFinderConnection = nil
local aimbotRenderConnection = nil

if not g:FindFirstChild("MainFrame") then
    local f = Instance.new("Frame")
    f.Name = "MainFrame"
    f.Parent = g
    f.Size = UDim2.new(0, 200, 0, 120)
    f.Position = UDim2.new(0, 50, 0, 150)
    f.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    f.BackgroundTransparency = 0.3
    f.Active = true
    f.Draggable = true
    f.Visible = false

    local u = Instance.new("UICorner")
    u.CornerRadius = UDim.new(0, 12)
    u.Parent = f

    local t = Instance.new("TextLabel")
    t.Parent = f
    t.Size = UDim2.new(1, 0, 0, 30)
    t.Text = "Headless Horseman Lock-On"
    t.BackgroundTransparency = 1
    t.TextColor3 = Color3.new(1, 1, 1)
    t.TextScaled = true

    local b = Instance.new("TextButton")
    b.Name = "Toggle"
    b.Parent = f
    b.Size = UDim2.new(0, 80, 0, 30)
    b.Position = UDim2.new(0, 10, 0, 40)
    b.Text = "OFF"
    b.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    b.TextColor3 = Color3.new(1, 1, 1)
    b.TextScaled = true

    local x = Instance.new("UICorner")
    x.CornerRadius = UDim.new(0, 8)
    x.Parent = b

    local d = Instance.new("TextBox")
    d.Name = "Prediction"
    d.Parent = f
    d.Size = UDim2.new(0, 180, 0, 30)
    d.Position = UDim2.new(0, 10, 0, 80)
    d.Text = "0.1"
    d.PlaceholderText = "Prediction"
    d.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    d.TextColor3 = Color3.new(1, 1, 1)
    d.ClearTextOnFocus = false
    d.TextScaled = true

    local y = Instance.new("UICorner")
    y.CornerRadius = UDim.new(0, 8)
    y.Parent = d
end

local f = g.MainFrame
local b = f.Toggle
local d = f.Prediction

b.MouseButton1Click:Connect(function()
    aimbotInternalToggle = not aimbotInternalToggle
    b.Text = aimbotInternalToggle and "ON" or "OFF"
    b.BackgroundColor3 = aimbotInternalToggle and Color3.fromRGB(0, 150, 0) or Color3.fromRGB(40, 40, 40)
end)

d.FocusLost:Connect(function()
    local n = tonumber(d.Text)
    if n then aimbotPrediction = n end
end)

local function startBossFinder()
    if aimbotBossFinderConnection then
        task.cancel(aimbotBossFinderConnection)
    end
    aimbotBossFinderConnection = task.spawn(function()
        while aimbotEnabled do
            task.wait(2)
            if aimbotInternalToggle then
                local s = workspace:FindFirstChild("Sleepy Hollow")
                local m = s and s:FindFirstChild("Modes")
                local w = m and m:FindFirstChild("Boss")
                local k = w and w:FindFirstChild("HeadlessHorsemanBoss")
                aimbotBoss = k and k:FindFirstChild("HeadlessHorseman")
            else
                aimbotBoss = nil
            end
        end
        aimbotBoss = nil
    end)
end

local function startRenderStepped()
    if aimbotRenderConnection then
        aimbotRenderConnection:Disconnect()
    end
    aimbotRenderConnection = r.RenderStepped:Connect(function()
        if aimbotEnabled and aimbotInternalToggle and aimbotBoss and aimbotBoss.Parent then
            local e = aimbotBoss:FindFirstChild("Torso") or aimbotBoss:FindFirstChild("UpperTorso")
            if e then
                local q = e.Position + e.Velocity * aimbotPrediction
                c.CFrame = CFrame.new(c.CFrame.Position, q)
            end
        end
    end)
end

local function toggleAimbot(enabled)
    aimbotEnabled = enabled
    f.Visible = enabled
    
    if enabled then
        startBossFinder()
        startRenderStepped()
    else
        aimbotInternalToggle = false
        b.Text = "OFF"
        b.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
        aimbotBoss = nil
        if aimbotBossFinderConnection then
            task.cancel(aimbotBossFinderConnection)
            aimbotBossFinderConnection = nil
        end
        if aimbotRenderConnection then
            aimbotRenderConnection:Disconnect()
            aimbotRenderConnection = nil
        end
    end
end

-- GUI Creation
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

if not Rayfield then
    warn("Failed to load Rayfield library")
    return
end

local Window = Rayfield:CreateWindow({
    Name = "Chaos Hub",
    Icon = 0,
    LoadingTitle = "Chaos",
    LoadingSubtitle = "by Chaos Hub",
    Theme = "Ocean",
    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false,
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "G&B Hub"
    },
    Discord = {
        Enabled = true,
        Invite = "",
        RememberJoins = true
    }
})

local Tab = Window:CreateTab("Main", "album")
local Section = Tab:CreateSection("Main Functions")

local esp_Tab = Window:CreateTab("ESP", "target")
local esp_Section = esp_Tab:CreateSection("ESP Functions")

local player_Tab = Window:CreateTab("Player", "person-standing")
local player_Section = player_Tab:CreateSection("Aux. Player Functions")

local misc_Tab = Window:CreateTab("Misc", "settings")
local misc_Section = misc_Tab:CreateSection("Miscellaneous Functions")

local aimbot_Tab = Window:CreateTab("Aimbot", "crosshair")
local aimbot_Section = aimbot_Tab:CreateSection("Headless Horseman Aimbot")

-- Aimbot Tab
aimbot_Tab:CreateToggle({
    Name = "Headless Aimbot By Refs",
    CurrentValue = false,
    Flag = "HeadlessAimbot", 
    Callback = function(Value)
        toggleAimbot(Value)
    end
})

-- Main Tab
Tab:CreateToggle({
    Name = "WalkSpeed Freeze",
    CurrentValue = false,
    Flag = "WalkSpeed", 
    Callback = function(Value)
        walkSpeedToggled = Value
        changeWalkSpeed(walkSpeedValue, walkSpeedToggled)
    end
})

Tab:CreateInput({
   Name = "WalkSpeed",
   CurrentValue = "16",
   PlaceholderText = "WalkSpeed",
   RemoveTextAfterFocusLost = false,
   Flag = "Input1",
   Callback = function(Value)
       local val = tonumber(Value)
       if val then
           walkSpeedValue = val
           changeWalkSpeed(val, walkSpeedToggled)
       end
   end
})

Tab:CreateToggle({
    Name = "Kill Aura",
    CurrentValue = false,
    Flag = "KillAura", 
    Callback = function(Value)
        killAuraToggled = Value
        if Value then
            task.wait(0.5)
            createHitBox()
        else
            if not shoveAuraToggled then
                if killAuraConnection then
                    killAuraConnection:Disconnect()
                    killAuraConnection = nil
                end
                observerOnline = false
                isDead = false
                
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local hitbox = LocalPlayer.Character.HumanoidRootPart:FindFirstChild("Hitbox")
                    if hitbox then hitbox:Destroy() end
                end
            else
                createHitBox()
            end
        end
    end
})

Tab:CreateToggle({
    Name = "Kill Bomber",
    CurrentValue = false,
    Flag = "KillBomber", 
    Callback = function(Value)
        killBomberToggled = Value
    end
})

Tab:CreateToggle({
    Name = "Shove Aura",
    CurrentValue = false,
    Flag = "ShoveAura", 
    Callback = function(Value)
        shoveAuraToggled = Value
        if Value then
            task.wait(0.5)
            createHitBox()
        else
            if not killAuraToggled then
                if killAuraConnection then
                    killAuraConnection:Disconnect()
                    killAuraConnection = nil
                end
                observerOnline = false
                isDead = false
                
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local hitbox = LocalPlayer.Character.HumanoidRootPart:FindFirstChild("Hitbox")
                    if hitbox then hitbox:Destroy() end
                end
            else
                createHitBox()
            end
        end
    end
})

Tab:CreateSlider({
   Name = "Shove Radius",
   Range = {1, 15},
   Increment = 1,
   Suffix = " studs",
   CurrentValue = shoveRadius,
   Flag = "ShoveRadiusSlider",
   Callback = function(Value)
        setShoveRadius(Value)
   end
})

Tab:CreateSlider({
   Name = "Max Shove Per Cycle",
   Range = {1, 20},
   Increment = 1,
   Suffix = " zombies",
   CurrentValue = maxShovePerCycle,
   Flag = "MaxShoveSlider",
   Callback = function(Value)
        setMaxShovePerCycle(Value)
   end
})

Tab:CreateSlider({
   Name = "Max Kill Aura Attacks Per Frame",
   Range = {1, 20},
   Increment = 1,
   Suffix = " zombies",
   CurrentValue = killAuraMaxAttacksPerFrame,
   Flag = "MaxKillAuraSlider",
   Callback = function(Value)
        setKillAuraMaxAttacksPerFrame(Value)
   end
})

Tab:CreateToggle({
    Name = "Head Lock",
    CurrentValue = false,
    Flag = "HeadLock", 
    Callback = function(Value)
        changeBayonet(Value)
        changeMelee(Value)
    end
})

Tab:CreateButton({
    Name = "Lights On (Saint Petersburg)",
    Callback = function()
        pcall(onLights)
    end
})

Tab:CreateToggle({
    Name = "Auto play",
    CurrentValue = false,
    Flag = "Autoplay", 
    Callback = function(Value)
        autoplay = Value
    end
})

Tab:CreateToggle({
    Name = "Auto Repair",
    CurrentValue = false,
    Flag = "AutoRepair",
    Callback = function(Value)
        autoRepair(Value)
    end
})

Tab:CreateToggle({
    Name = "Auto Equip Hammer",
    CurrentValue = false,
    Flag = "AutoEquipHammer",
    Callback = function(Value)
        autoEquipHammerToggled = Value
    end
})

Tab:CreateToggle({
    Name = "Zombie Hitbox Expander",
    CurrentValue = false,
    Flag = "HitboxExpander",
    Callback = function(Value)
        toggleHitboxExpander(Value)
    end
})

Tab:CreateSlider({
   Name = "Zombie Hitbox Size",
   Range = {1, 30},
   Increment = 1,
   Suffix = " studs",
   CurrentValue = hitboxSize,
   Flag = "HitboxSizeSlider",
   Callback = function(Value)
        setHitboxSize(Value)
   end
})

-- Player Tab
player_Tab:CreateToggle({
    Name = "Medic Player ESP",
    CurrentValue = false,
    Flag = "player_esp", 
    Callback = function(Value)
        espLifeToggled = Value
        checkPlayersLife()
    end
})

player_Tab:CreateToggle({
    Name = "Father Infection ESP",
    CurrentValue = false,
    Flag = "father_infection", 
    Callback = function(Value)
        espLifeToggled = Value
        checkPlayersLife()
    end
})

-- ESP Tab
esp_Tab:CreateToggle({
    Name = "ESP Runner",
    CurrentValue = false,
    Flag = "ESP_1",
    Callback = function(Value)
        espRToggled = Value
    end
})

esp_Tab:CreateToggle({
    Name = "ESP Bomber",
    CurrentValue = false,
    Flag = "ESP_2",
    Callback = function(Value)
        espBToggled = Value
    end
})

esp_Tab:CreateToggle({
    Name = "ESP Igniter",
    CurrentValue = false,
    Flag = "ESP_3",
    Callback = function(Value)
        espIToggled = Value
    end
})

esp_Tab:CreateToggle({
    Name = "ESP Cuirassier",
    CurrentValue = false,
    Flag = "ESP_4",
    Callback = function(Value)
        espCuToogled = Value
    end
})

esp_Tab:CreateToggle({
    Name = "ESP Boss",
    CurrentValue = false,
    Flag = "ESP_5",
    Callback = function(Value)
        espBossToggled = Value
        if bossFolder then
            if Value then
                for _, child in pairs(bossFolder:GetChildren()) do
                    if not child:FindFirstChild("Highlight") then
                        local Highlight = Instance.new("Highlight")
                        Highlight.Parent = child
                        Highlight.Adornee = child
                        Highlight.FillColor = Color3.fromRGB(255, 0, 0)
                    end
                end
            else
                for _, child in pairs(bossFolder:GetChildren()) do
                    if child:FindFirstChild("Highlight") then
                        child.Highlight:Destroy()
                    end
                end
            end
        end
    end
})

-- Misc Tab
misc_Tab:CreateToggle({
    Name = "Fullbright",
    CurrentValue = false,
    Flag = "Fullbright",
    Callback = function(Value)
        toggleFullbright(Value)
    end
})

misc_Tab:CreateToggle({
    Name = "Killbrick Protection",
    CurrentValue = false,
    Flag = "KillbrickProtection",
    Callback = function(Value)
        toggleKillbrick(not Value)
    end
})

misc_Tab:CreateButton({
    Name = "Purchase Le Revenant",
    Callback = function()
        pcall(function()
            game:GetService("ReplicatedStorage").Events.Customize.PurchaseEvent:FireServer("Le Revenant")
        end)
    end
})

misc_Tab:CreateButton({
    Name = "Purchase Baguette",
    Callback = function()
        pcall(function()
            game:GetService("ReplicatedStorage").Events.Customize.PurchaseEvent:FireServer("Baguette")
        end)
    end
})

end)

if not success then
    warn("Script Load Error: " .. tostring(errorMsg))
end
