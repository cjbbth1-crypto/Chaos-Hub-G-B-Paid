local success, errorMsg = pcall(function()

local LocalPlayer = game:GetService("Players").LocalPlayer
local RunService = game:GetService("RunService")

-- ESP
espRToggled = false
espBToggled = false
espIToggled = false
espCuToogled = false
espBossToggled = false

local bossFolder = nil
pcall(function()
    bossFolder = workspace:WaitForChild("Sleepy Hollow", 10).Modes.Boss.HeadlessHorsemanBoss
end)

if bossFolder then
    bossFolder.ChildAdded:Connect(
        function(child)
            if espBossToggled then
                local Highlight = Instance.new("Highlight")
                Highlight.Parent = child
                Highlight.Adornee = child
                Highlight.FillColor = Color3.fromRGB(255, 0, 0)
            end
        end
    )

    -- Apply to existing children if any
    for _, child in pairs(bossFolder:GetChildren()) do
        if espBossToggled then
            local Highlight = Instance.new("Highlight")
            Highlight.Parent = child
            Highlight.Adornee = child
            Highlight.FillColor = Color3.fromRGB(255, 0, 0)
        end
    end
end

workspace.Camera.ChildAdded:Connect(
    function(child)
        if child.Name == "m_Zombie" then
            local Origin = child:WaitForChild("Orig", 5)
            if Origin and Origin.Value ~= nil then
                local zombie = Origin.Value:FindFirstChild("Zombie")
                if not zombie then return end
                
                if espRToggled then
                    if zombie.WalkSpeed > 16 then
                        local Highlight = Instance.new("Highlight")
                        Highlight.Parent = child
                        Highlight.Adornee = child
                    end
                end
                if espBToggled then
                    if child:FindFirstChild("Barrel") ~= nil then
                        local Highlight = Instance.new("Highlight")
                        Highlight.Parent = child
                        Highlight.Adornee = child
                        Highlight.FillColor = Color3.fromRGB(65,105,225)
                    end
                end
                if espIToggled then 
                    if child:FindFirstChild("Whale Oil Lantern") ~= nil then
                        local Highlight = Instance.new("Highlight")
                        Highlight.Parent = child
                        Highlight.Adornee = child
                        Highlight.FillColor = Color3.fromRGB(255,255,51)
                    end
                end
                if espCuToogled then
                    if child:FindFirstChild("Sword") ~= nil then
                        local Highlight = Instance.new("Highlight")
                        Highlight.Parent = child
                        Highlight.Adornee = child
                        Highlight.FillColor = Color3.fromRGB(65,105,225)  
                    end
                end       
            end
        end
    end
)

-- ESP Players
espLifeToggled = false

function checkPlayersLife()
    if espLifeToggled == false then
        local Players = workspace.Players:GetChildren()
        for i, player in pairs(Players) do
            if player:FindFirstChild("Highlight") ~= nil then
                player:FindFirstChild("Highlight"):Destroy()
            end
        end
    end

    while espLifeToggled do
        local Players = workspace.Players:GetChildren()
        for i, player in pairs(Players) do
            local humanoid = player:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health < 60 and player.Name ~= LocalPlayer.Name and (LocalPlayer.Backpack:FindFirstChild("Medical Supplies") or (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Medical Supplies") and LocalPlayer.Character["Medical Supplies"]:IsA("Tool"))) then
                if player:FindFirstChild("Highlight") == nil then
                    local Highlight = Instance.new("Highlight")
                    Highlight.Parent = player
                    Highlight.Adornee = player
                    Highlight.FillColor = Color3.fromRGB(255, 169, 108)
                    Highlight.FillTransparency = 0.8
                    Highlight.OutlineColor = Color3.fromRGB(255, 206, 108)
                    Highlight.OutlineTransparency = 0.2
                end
            else
                if player:FindFirstChild("Highlight") ~= nil then
                    player:FindFirstChild("Highlight"):Destroy()
                end
            end

            if LocalPlayer.Backpack:FindFirstChild("Mercy") or (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Mercy") and LocalPlayer.Character["Mercy"]:IsA("Tool")) then
                local userStates = player:FindFirstChild("UserStates")
                if userStates and userStates:FindFirstChild("Infected") then
                    if userStates.Infected.Value > 10 and player:FindFirstChild("Highlight") == nil then
                        if userStates.Infected.Value > 89 then
                            if player:FindFirstChild("Highlight") ~= nil then
                                local Highlight = player:FindFirstChild("Highlight")
                                Highlight.FillColor = Color3.fromRGB(178,34,34)
                            else
                                local Highlight = Instance.new("Highlight")
                                Highlight.Parent = player
                                Highlight.Adornee = player
                                Highlight.FillColor = Color3.fromRGB(178,34,34)
                            end
                        else
                            local Highlight = Instance.new("Highlight")
                            Highlight.Parent = player
                            Highlight.Adornee = player
                            Highlight.FillColor = Color3.fromRGB(255, 169, 108)
                            Highlight.FillTransparency = 0.8
                            Highlight.OutlineColor = Color3.fromRGB(255, 206, 108)
                            Highlight.OutlineTransparency = 0.2
                        end
                    else 
                        if player:FindFirstChild("Highlight") ~= nil and userStates.Infected.Value == 0 then
                            player:FindFirstChild("Highlight"):Destroy()
                        end
                    end
                end
            end
        end
        task.wait(2.0)
    end
end

toolEquip = true

-- Enhanced Kill Aura & Shove Aura
observerOnline = false
killAuraToggled = false
shoveAuraToggled = false
isDead = false
killAuraConnection = nil

shoveRadius = 8
maxShovePerCycle = 10
local shoveThrottleTime = 0.2
local stunCooldowns = {}
local lastShoveTime = 0

local killAuraRadius = 13

local raycastParams = RaycastParams.new()
raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
raycastParams.FilterType = Enum.RaycastFilterType.Exclude

local params = OverlapParams.new()
params.FilterDescendantsInstances = {LocalPlayer.Character}

function getEquippedWeapon()
    if not LocalPlayer.Character then return nil end
    
    for _, child in pairs(LocalPlayer.Character:GetChildren()) do
        if child:IsA("Tool") then
            if child:FindFirstChild("RemoteEvent") or child:FindFirstChild("Remote") then
                return child
            end
        end
    end
    
    return nil
end

function canWeaponShove(weapon)
    if not weapon then return false end
    
    local shoveWeapons = {
        "Pickaxe", 
        "Axe",
        "Carbine",
        "Navy Pistol"
    }
    
    for _, shoveWeapon in pairs(shoveWeapons) do
        if weapon.Name:lower():find(shoveWeapon:lower()) then
            return true
        end
    end
    
    if weapon:GetAttribute("CanShove") == true then
        return true
    end
    
    return false
end

function shoveAttack(weapon, hit, hitPart)
    if not weapon or not hit then return end
    
    local currentTime = tick()
    local zombieId = tostring(hit)
    
    stunCooldowns[zombieId] = currentTime
    
    local remoteEvent = weapon:FindFirstChild("RemoteEvent") or weapon:FindFirstChild("Remote")
    if not remoteEvent then return end
    
    task.spawn(function()
        pcall(function()
            remoteEvent:FireServer("FeedbackStun", hit, hitPart.Position)
            
            if weapon.Name:lower():find("axe") then
                remoteEvent:FireServer("BraceBlock")
                remoteEvent:FireServer("StopBraceBlock")
                remoteEvent:FireServer("FeedbackStunObject", hit, hitPart.Position)
            end
            
            if weapon.Name:lower():find("pickaxe") then
                remoteEvent:FireServer("Swing", "Shove")
                remoteEvent:FireServer("FeedbackStun", hit, hitPart.Position)
            end
            
            if weapon.Name:lower():find("carbine") then
                remoteEvent:FireServer("Shove")
                remoteEvent:FireServer("FeedbackStun", hit, hitPart.Position)
            end
            
            if weapon.Name:lower():find("navy pistol") then
                remoteEvent:FireServer("Shove")
            end
        end)
    end)
end

function attackWithWeapon(weapon, hit, hitPart, calc, normal)
    if not weapon then return end
    
    local remoteEvent = weapon:FindFirstChild("RemoteEvent") or weapon:FindFirstChild("Remote")
    if not remoteEvent then return end
    
    local success = false
    
    pcall(function()
        remoteEvent:FireServer("Swing", "Thrust")
        remoteEvent:FireServer("HitZombie", hit, hitPart.CFrame.Position, true, calc * 25, "Head", normal)
        success = true
    end)
    
    if not success then
        pcall(function()
            remoteEvent:FireServer("Bayonet_HitZombie", hit, hitPart.CFrame.Position, true, "Head")
            success = true
        end)
    end
    
    if not success then
        pcall(function()
            remoteEvent:FireServer("HitZombie", hit, hitPart.CFrame.Position, true, calc * 25, "Head", normal)
        end)
    end
end

function detectEnemy(hitbox, hrp)
    if killAuraConnection then
        killAuraConnection:Disconnect()
    end
    
    killAuraConnection = RunService.Heartbeat:Connect(function()
        if not killAuraToggled and not shoveAuraToggled then
            isDead = false
            observerOnline = false
            if killAuraConnection then
                killAuraConnection:Disconnect()
                killAuraConnection = nil
            end
            return
        end

        if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            return
        end

        if not hitbox or not hitbox.Parent then
            return
        end

        local currentTime = tick()
        
        if currentTime - lastShoveTime < 0.05 then
            return
        end

        local success, parts = pcall(function()
            return workspace:GetPartsInPart(hitbox, params)
        end)

        if not success then
            return
        end

        local zombiesToShove = {}
        local zombiesToAttack = {}
        local equippedWeapon = getEquippedWeapon()

        for i, part in pairs(parts) do
            if part.Parent and part.Parent.Name == "m_Zombie" then
                pcall(function()
                    local Origin = part.Parent:FindFirstChild("Orig")
                    if Origin and Origin.Value then
                        local zombie = Origin.Value:FindFirstChild("Zombie")
                        if not zombie then return end
                        
                        local hit = Origin.Value
                        if not hit or not hit:FindFirstChild("Head") or not hit:FindFirstChild("HumanoidRootPart") then
                            return
                        end

                        local distance = LocalPlayer:DistanceFromCharacter(hit.HumanoidRootPart.CFrame.Position)
                        
                        if shoveAuraToggled and equippedWeapon and canWeaponShove(equippedWeapon) and distance <= shoveRadius then
                            local zombieId = tostring(hit)
                            if not stunCooldowns[zombieId] or currentTime - stunCooldowns[zombieId] >= 1.0 then
                                local raycastResult = workspace:Raycast(hrp.CFrame.Position, hit.Head.CFrame.Position - hrp.CFrame.Position, raycastParams)
                                if raycastResult then
                                    table.insert(zombiesToShove, {
                                        hit = hit, 
                                        part = part, 
                                        zombie = zombie, 
                                        raycast = raycastResult,
                                        priority = zombie.WalkSpeed > 16 and 1 or 2
                                    })
                                end
                            end
                        end
                        
                        if killAuraToggled and distance <= killAuraRadius then
                            local zombieId = tostring(hit)
                            local willBeShoved = false
                            
                            if shoveAuraToggled and equippedWeapon and canWeaponShove(equippedWeapon) and distance <= shoveRadius then
                                if not stunCooldowns[zombieId] or currentTime - stunCooldowns[zombieId] >= 1.0 then
                                    willBeShoved = true
                                end
                            end
                            
                            if not willBeShoved then
                                local raycastResult = workspace:Raycast(hrp.CFrame.Position, hit.Head.CFrame.Position - hrp.CFrame.Position, raycastParams)
                                if raycastResult then
                                    local calc = (raycastResult.Position - hrp.CFrame.Position)
                                    if calc:Dot(calc) > 1 then
                                        calc = calc.Unit
                                    end
                                    
                                    table.insert(zombiesToAttack, {
                                        hit = hit,
                                        part = part,
                                        zombie = zombie,
                                        raycast = raycastResult,
                                        calc = calc
                                    })
                                end
                            end
                        end
                    end
                end)
            end
        end

        if #zombiesToShove > 0 and equippedWeapon and canWeaponShove(equippedWeapon) and toolEquip then
            table.sort(zombiesToShove, function(a, b) return a.priority < b.priority end)
            
            local shoveCount = math.min(#zombiesToShove, maxShovePerCycle)
            
            for i = 1, shoveCount do
                local zombieData = zombiesToShove[i]
                shoveAttack(equippedWeapon, zombieData.hit, zombieData.hit.Head)
            end
            
            lastShoveTime = currentTime
            return
        end
        
        if #zombiesToAttack > 0 and equippedWeapon and toolEquip then
            for _, zombieData in pairs(zombiesToAttack) do
                if zombieData.zombie.WalkSpeed > 16 then
                    attackWithWeapon(equippedWeapon, zombieData.hit, zombieData.hit.Head, zombieData.calc, zombieData.raycast.Normal)
                else
                    if not zombieData.part.Parent:FindFirstChild("Barrel") then
                        attackWithWeapon(equippedWeapon, zombieData.hit, zombieData.hit.Head, zombieData.calc, zombieData.raycast.Normal)
                    end
                end
            end
        end
    end)
end

function setShoveRadius(newRadius)
    shoveRadius = newRadius
    
    if (killAuraToggled or shoveAuraToggled) and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        observerOnline = false
        if killAuraConnection then
            killAuraConnection:Disconnect()
            killAuraConnection = nil
        end
        
        local existingHitbox = LocalPlayer.Character.HumanoidRootPart:FindFirstChild("Hitbox")
        if existingHitbox then
            existingHitbox:Destroy()
        end
        
        task.wait(0.1)
        createHitBox()
    end
end

function setMaxShovePerCycle(newMax)
    maxShovePerCycle = newMax
end

function createHitBox()
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end

    local torso = LocalPlayer.Character.HumanoidRootPart
    local existingHitbox = torso:FindFirstChild("Hitbox")
    
    local hitboxSize, hitboxOffset
    
    if shoveAuraToggled and not killAuraToggled then
        hitboxSize = Vector3.new(shoveRadius * 2, 6, shoveRadius * 2)
        hitboxOffset = CFrame.new(0, 0, -shoveRadius * 0.6)
    elseif killAuraToggled and not shoveAuraToggled then
        hitboxSize = Vector3.new(killAuraRadius * 2, 7, killAuraRadius * 2)
        hitboxOffset = CFrame.new(0, 0, -killAuraRadius * 0.6)
    else
        local maxRadius = math.max(shoveRadius, killAuraRadius)
        hitboxSize = Vector3.new(maxRadius * 2, 7, maxRadius * 2)
        hitboxOffset = CFrame.new(0, 0, -maxRadius * 0.6)
    end
    
    if existingHitbox then
        existingHitbox.Size = hitboxSize
        existingHitbox.CFrame = torso.CFrame * hitboxOffset
        
        if not observerOnline then
            observerOnline = true
            detectEnemy(existingHitbox, torso)
        end
        return true
    else
        local hitbox = Instance.new("Part")
        hitbox.Name = "Hitbox"
        hitbox.Parent = torso
        hitbox.Anchored = false
        hitbox.Massless = true
        hitbox.CanCollide = false
        hitbox.CanTouch = false
        hitbox.Transparency = 1
        hitbox.Size = hitboxSize
        hitbox.CFrame = torso.CFrame * hitboxOffset

        local weld = Instance.new("WeldConstraint")
        weld.Parent = torso
        weld.Part0 = hitbox
        weld.Part1 = torso

        if not observerOnline then
            observerOnline = true
            detectEnemy(hitbox, torso)
        end

        return true
    end
end

function onLights()
    local ligthPost = game:GetService("Workspace"):waitForChild("Saint Petersburg").Modes.Holdout:waitForChild("LampPosts"):GetChildren()

    for i, part in pairs(ligthPost) do
        if part:FindFirstChild("Metal") ~= nil then
            local Metal = part:FindFirstChild("Metal")
            Metal.Light.PointLight.Enabled = true
            Metal.Light.Visible = true
        end
    end
end

local connection = nil

local function changeWalkSpeed(newValue, walkSpeedToggled)
    local workPlayer = LocalPlayer.Character
    if workPlayer and workPlayer:FindFirstChild("Humanoid") then
        workPlayer.Humanoid.WalkSpeed = newValue
        if walkSpeedToggled then
            connection = workPlayer.Humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function() 
                workPlayer.Humanoid.WalkSpeed = newValue 
            end)
        else
            if connection ~= nil then
                connection:Disconnect()
                connection = nil
            end
        end
    end
end

walkSpeedToggled = false
walkSpeedValue = 16
workspace.Players.ChildAdded:Connect(
   function(child)
    changeWalkSpeed(walkSpeedValue, walkSpeedToggled)
   end
)

local namecall
autoplay = false

namecall = hookmetamethod(game, "__namecall", function(self, ...)
    local args = {...}
    local method = getnamecallmethod():lower()

    if not checkcaller() and self.Name == "RemoteEvent" and method == "fireserver" then
        if autoplay then
            if args[1] ~= nil then
                if args[1] == "UpdateAccuracy" then
                    args[2] = 100
                    return namecall(self, unpack(args))
                end
            end
        end
        return namecall(self, unpack(args))
    end
    return namecall(self, ...)
end)

-- Bayonet Head Lock
local FlintLock = require(game:GetService("ReplicatedStorage").Modules.Weapons:waitForChild("Flintlock"))
local originFunction_ = FlintLock.BayonetHitCheck

local v_u_1 = {}
function v_u_1.BayonetHitCheck(p115, p116, p117, p118, p119)
    local v120 = workspace:Raycast(p116, p117, p118)
    if v120 then
        if v120.Instance.Parent.Name == "m_Zombie" then
            local v121 = p118.FilterDescendantsInstances
            local v122 = v120.Instance
            table.insert(v121, v122)
            p118.FilterDescendantsInstances = v121
            local v123 = v120.Instance.Parent:FindFirstChild("Orig")
            if v123 then
                local Head = ""
                for i, part in pairs(v120.Instance.Parent:GetChildren()) do
                    if part.Name == "Head" and (part.ClassName == "Part" or part.ClassName == "MeshPart") then
                        Head = part
                    end
                end
                p115.remoteEvent:FireServer("Bayonet_HitZombie", v123.Value, Head.CFrame.Position, true, "Head")
            end
            return 2
        end
    end
    return 0
end

function changeBayonet(value)
   if value then
      FlintLock.BayonetHitCheck = v_u_1.BayonetHitCheck
   else
      FlintLock.BayonetHitCheck = originFunction_
   end
end

-- Melee Head Lock
local MeleeBase = require(game:GetService("ReplicatedStorage").Modules.Weapons:waitForChild("MeleeBase"))
local originFunction = MeleeBase.MeleeHitCheck

local u1 = {}
function u1.MeleeHitCheck(p100, p101, p102, p103, p104, p105)
    local v106 = workspace:Raycast(p101, p102, p103)
    if v106 then
        if v106.Instance.Parent.Name == "m_Zombie" then
            local v107 = p103.FilterDescendantsInstances
            local v108 = v106.Instance
            table.insert(v107, v108)
            p103.FilterDescendantsInstances = v107
            local v109 = v106.Instance.Parent:FindFirstChild("Orig")
            if v109 then
                if not p104[v109] or p104[v109] < (p100.Stats.MaxHits or 3) then
                    if not p105 then
                        local Head = ""
                        for i, part in pairs(v106.Instance.Parent:GetChildren()) do
                            if part.Name == "Head" and (part.ClassName == "Part" or part.ClassName == "MeshPart") then
                                Head = part
                            end
                        end
                        local u112 = v109.Value
                        local v113 = Head.CFrame.Position - p101
                        if v113:Dot(v113) > 1 then
                            v113 = v113.Unit
                        end
                        local v114 = v113 * 25
                        p100.remoteEvent:FireServer("HitZombie", u112, Head.CFrame.Position, true, v114, "Head", v106.Normal)
                    end
                    if p104[v109] then
                        p104[v109] = p104[v109] + 1
                    else
                        table.insert(p104, v109)
                        p104[v109] = 1
                    end
                end
            end
            return 1
        end
    end
    return 0
end

function changeMelee(value)
   if value then
      MeleeBase.MeleeHitCheck = u1.MeleeHitCheck
   else
      MeleeBase.MeleeHitCheck = originFunction
   end
end

-- OPTIMIZED Zombie Hitbox Expander
local hitboxEnabled = false
local hitboxSize = 10
local zombieFolder = workspace:WaitForChild("Zombies")
local zombieFolderConnection = nil
local cameraConnection = nil
local hitboxUpdateLoop = nil
local trackedZombies = {}

local function expandHitbox(zombie)
    if not hitboxEnabled then return end
    if not zombie or not zombie.Parent then return end
    
    local hrp = zombie:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    local zombieId = tostring(zombie)
    local existingHitbox = hrp:FindFirstChild("HitboxPart")
    local newSize = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
    
    if existingHitbox then
        if trackedZombies[zombieId] and trackedZombies[zombieId].size == hitboxSize then
            return
        end
        existingHitbox.Size = newSize
        trackedZombies[zombieId] = {size = hitboxSize, hitbox = existingHitbox}
    else
        local hitbox = Instance.new("Part")
        hitbox.Name = "HitboxPart"
        hitbox.Size = newSize
        hitbox.Transparency = 1
        hitbox.CanCollide = false
        hitbox.Massless = true
        hitbox.Anchored = false
        hitbox.CFrame = hrp.CFrame
        hitbox.Parent = hrp
        
        local weld = Instance.new("WeldConstraint")
        weld.Part0 = hrp
        weld.Part1 = hitbox
        weld.Parent = hitbox
        
        trackedZombies[zombieId] = {size = hitboxSize, hitbox = hitbox}
    end
end

local function removeZombieHitbox(zombie)
    if not zombie then return end
    local zombieId = tostring(zombie)
    
    if trackedZombies[zombieId] then
        if trackedZombies[zombieId].hitbox and trackedZombies[zombieId].hitbox.Parent then
            trackedZombies[zombieId].hitbox:Destroy()
        end
        trackedZombies[zombieId] = nil
    end
    
    local hrp = zombie:FindFirstChild("HumanoidRootPart")
    if hrp then
        local hitbox = hrp:FindFirstChild("HitboxPart")
        if hitbox then
            hitbox:Destroy()
        end
    end
end

local function removeAllHitboxes()
    for zombieId, data in pairs(trackedZombies) do
        if data.hitbox and data.hitbox.Parent then
            data.hitbox:Destroy()
        end
    end
    trackedZombies = {}
    
    for _, zombie in pairs(zombieFolder:GetChildren()) do
        removeZombieHitbox(zombie)
    end
    
    for _, zombie in pairs(workspace.Camera:GetChildren()) do
        if zombie.Name == "m_Zombie" then
            removeZombieHitbox(zombie)
        end
    end
end

local function setHitboxSize(newSize)
    hitboxSize = newSize
    if hitboxEnabled then
        trackedZombies = {}
        
        for _, zombie in pairs(zombieFolder:GetChildren()) do
            expandHitbox(zombie)
        end
        
        for _, zombie in pairs(workspace.Camera:GetChildren()) do
            if zombie.Name == "m_Zombie" then
                expandHitbox(zombie)
            end
        end
    end
end

local function toggleHitboxExpander(enabled)
    hitboxEnabled = enabled
    
    if zombieFolderConnection then
        zombieFolderConnection:Disconnect()
        zombieFolderConnection = nil
    end
    
    if cameraConnection then
        cameraConnection:Disconnect()
        cameraConnection = nil
    end
    
    if hitboxUpdateLoop then
        hitboxUpdateLoop:Disconnect()
        hitboxUpdateLoop = nil
    end
    
    if enabled then
        for _, zombie in pairs(zombieFolder:GetChildren()) do
            expandHitbox(zombie)
        end
        
        for _, zombie in pairs(workspace.Camera:GetChildren()) do
            if zombie.Name == "m_Zombie" then
                expandHitbox(zombie)
            end
        end
        
        zombieFolderConnection = zombieFolder.ChildAdded:Connect(function(zombie)
            task.wait(0.1)
            expandHitbox(zombie)
        end)
        
        zombieFolder.ChildRemoved:Connect(function(zombie)
            removeZombieHitbox(zombie)
        end)
        
        cameraConnection = workspace.Camera.ChildAdded:Connect(function(zombie)
            if zombie.Name == "m_Zombie" then
                task.wait(0.1)
                expandHitbox(zombie)
            end
        end)
        
        workspace.Camera.ChildRemoved:Connect(function(zombie)
            if zombie.Name == "m_Zombie" then
                removeZombieHitbox(zombie)
            end
        end)
        
        local lastUpdate = 0
        hitboxUpdateLoop = RunService.Heartbeat:Connect(function()
            if not hitboxEnabled then
                if hitboxUpdateLoop then
                    hitboxUpdateLoop:Disconnect()
                    hitboxUpdateLoop = nil
                end
                return
            end
            
            local currentTime = tick()
            if currentTime - lastUpdate < 2 then
                return
            end
            lastUpdate = currentTime
            
            for _, zombie in pairs(zombieFolder:GetChildren()) do
                if zombie and zombie.Parent then
                    expandHitbox(zombie)
                end
            end
            
            for _, zombie in pairs(workspace.Camera:GetChildren()) do
                if zombie.Name == "m_Zombie" and zombie.Parent then
                    expandHitbox(zombie)
                end
            end
        end)
    else
        removeAllHitboxes()
    end
end

-- Fullbright System
local Light = game:GetService("Lighting")
local fullbrightEnabled = false
local fullbrightConnection = nil
local originalLightingSettings = {
    Ambient = Light.Ambient,
    ColorShift_Bottom = Light.ColorShift_Bottom,
    ColorShift_Top = Light.ColorShift_Top,
    OutdoorAmbient = Light.OutdoorAmbient,
    Brightness = Light.Brightness
}

local function doFullbright()
    if not fullbrightEnabled then return end
    
    Light.Ambient = Color3.new(1, 1, 1)
    Light.ColorShift_Bottom = Color3.new(1, 1, 1)
    Light.ColorShift_Top = Color3.new(1, 1, 1)
    Light.OutdoorAmbient = Color3.new(1, 1, 1)
    Light.Brightness = 2
end

local function restoreLighting()
    Light.Ambient = originalLightingSettings.Ambient
    Light.ColorShift_Bottom = originalLightingSettings.ColorShift_Bottom
    Light.ColorShift_Top = originalLightingSettings.ColorShift_Top
    Light.OutdoorAmbient = originalLightingSettings.OutdoorAmbient
    Light.Brightness = originalLightingSettings.Brightness
end

local function toggleFullbright(enabled)
    fullbrightEnabled = enabled
    
    if fullbrightConnection then
        fullbrightConnection:Disconnect()
        fullbrightConnection = nil
    end
    
    if enabled then
        doFullbright()
        fullbrightConnection = Light.LightingChanged:Connect(doFullbright)
    else
        restoreLighting()
    end
end

-- Killbrick Protection
local killbrickEnabled = true
local killbrickConnection = nil

local function toggleKillbrick(enabled)
    killbrickEnabled = enabled
    
    if killbrickConnection then
        killbrickConnection:Disconnect()
        killbrickConnection = nil
    end
    
    if not enabled then
        killbrickConnection = RunService.Heartbeat:Connect(function()
            if not LocalPlayer.Character then return end
            local humanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if not humanoidRootPart then return end
            
            local parts = workspace:GetPartBoundsInRadius(humanoidRootPart.Position, 10)
            for _, part in ipairs(parts) do
                part.CanTouch = false
            end
        end)
    else
        local parts = workspace:GetDescendants()
        for _, part in ipairs(parts) do
            if part:IsA("BasePart") then
                part.CanTouch = true
            end
        end
    end
end

-- Auto Repair System
local autoRepairToggled = false
local autoEquipHammerToggled = false
local autoRepairConnection = nil
local lastRepairTime = 0
local isRepairing = false
local repairCooldown = 0.1

local function equipHammer()
    local hammer = LocalPlayer.Backpack:FindFirstChild("Hammer")
    if not hammer then return false end

    local success = pcall(function()
        LocalPlayer.Character.Humanoid:EquipTool(hammer)
    end)
    
    if not success then return false end
    
    local attempts = 0
    while not LocalPlayer.Character:FindFirstChild("Hammer") and attempts < 10 do
        task.wait(0.1)
        attempts = attempts + 1
    end
    
    return LocalPlayer.Character:FindFirstChild("Hammer") ~= nil
end

local function performRepair()
    if isRepairing or not autoRepairToggled or 
       not LocalPlayer.Character or 
       not LocalPlayer.Character:FindFirstChild("Humanoid") or 
       not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or 
       not LocalPlayer.Character:FindFirstChild("Head") then
        return false
    end

    local currentTime = tick()
    if currentTime - lastRepairTime < repairCooldown then
        return false
    end

    local hammerTool = LocalPlayer.Character:FindFirstChild("Hammer")
    
    if not hammerTool and autoEquipHammerToggled then
        if not equipHammer() then
            return false
        end
        hammerTool = LocalPlayer.Character:FindFirstChild("Hammer")
    end
    
    if not hammerTool then
        return false
    end

    isRepairing = true

    local remoteEvent = hammerTool:FindFirstChild("RemoteEvent")
    if not remoteEvent then
        isRepairing = false
        return false
    end

    local repairParams = RaycastParams.new()
    repairParams.IgnoreWater = true
    repairParams.FilterDescendantsInstances = {LocalPlayer.Character}
    repairParams.FilterType = Enum.RaycastFilterType.Exclude

    local head = LocalPlayer.Character.Head
    local repaired = false

    local success = pcall(function()
        local direction = workspace.CurrentCamera.CFrame.LookVector
        local raycast = workspace:Raycast(
            head.Position,
            direction * 8,
            repairParams
        )

        if raycast and raycast.Instance then
            local buildingHealth = raycast.Instance.Parent:FindFirstChild("BuildingHealth") or 
                                 raycast.Instance.Parent.Parent:FindFirstChild("BuildingHealth")
            local constructHealth = raycast.Instance:FindFirstChild("ConstructHealth")

            if buildingHealth or constructHealth then
                remoteEvent:FireServer("Repair", buildingHealth or constructHealth)
                lastRepairTime = currentTime
                repaired = true
            end
        end
    end)

    if not success then
        isRepairing = false
        return false
    end

    isRepairing = false
    return repaired
end

local function autoRepair(Value)
    autoRepairToggled = Value

    if autoRepairToggled then
        isRepairing = false
        
        if autoRepairConnection then
            autoRepairConnection:Disconnect()
            autoRepairConnection = nil
        end

        autoRepairConnection = RunService.Heartbeat:Connect(function()
            if not autoRepairToggled then
                if autoRepairConnection then
                    autoRepairConnection:Disconnect()
                    autoRepairConnection = nil
                end
                return
            end
            
            if tick() - lastRepairTime >= repairCooldown then
                task.spawn(function()
                    pcall(performRepair)
                end)
            end
        end)
    else
        if autoRepairConnection then
            autoRepairConnection:Disconnect()
            autoRepairConnection = nil
        end
        
        isRepairing = false
    end
end

-- Cleanup on character death/respawn
task.spawn(function()
    while true do
        task.wait(5)
        local currentTime = tick()
        for zombieId, lastTime in pairs(stunCooldowns) do
            if currentTime - lastTime > 10 then
                stunCooldowns[zombieId] = nil
            end
        end
    end
end)

LocalPlayer.CharacterAdded:Connect(function(character)
    task.wait(1)
    
    stunCooldowns = {}
    lastShoveTime = 0
    
    if killAuraToggled or shoveAuraToggled then
        observerOnline = false
        if killAuraConnection then
            killAuraConnection:Disconnect()
            killAuraConnection = nil
        end
        createHitBox()
    end
    
    raycastParams.FilterDescendantsInstances = {character}
    params.FilterDescendantsInstances = {character}
    
    if not killbrickEnabled then
        toggleKillbrick(false)
    end
end)

-- Headless Aimbot Integration
local p = game:GetService("Players")
local r = game:GetService("RunService")
local l = p.LocalPlayer
local c = workspace.CurrentCamera
local g = l:WaitForChild("PlayerGui"):FindFirstChild("HorsemanLockOn") or Instance.new("ScreenGui")

g.Name = "HorsemanLockOn"
g.ResetOnSpawn = false
g.Parent = l:WaitForChild("PlayerGui")

local aimbotEnabled = false
local aimbotInternalToggle = false
local aimbotPrediction = 0.1
local aimbotBoss = nil
local aimbotBossFinderConnection = nil
local aimbotRenderConnection = nil

if not g:FindFirstChild("MainFrame") then
	local f = Instance.new("Frame")
	f.Name = "MainFrame"
	f.Parent = g
	f.Size = UDim2.new(0, 200, 0, 120)
	f.Position = UDim2.new(0, 50, 0, 150)
	f.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	f.BackgroundTransparency = 0.3
	f.Active = true
	f.Draggable = true
	f.Visible = false

	local u = Instance.new("UICorner")
	u.CornerRadius = UDim.new(0, 12)
	u.Parent = f

	local t = Instance.new("TextLabel")
	t.Parent = f
	t.Size = UDim2.new(1, 0, 0, 30)
	t.Text = "Headless Horseman Lock-On"
	t.BackgroundTransparency = 1
	t.TextColor3 = Color3.new(1, 1, 1)
	t.TextScaled = true

	local b = Instance.new("TextButton")
	b.Name = "Toggle"
	b.Parent = f
	b.Size = UDim2.new(0, 80, 0, 30)
	b.Position = UDim2.new(0, 10, 0, 40)
	b.Text = "OFF"
	b.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	b.TextColor3 = Color3.new(1, 1, 1)
	b.TextScaled = true

	local x = Instance.new("UICorner")
	x.CornerRadius = UDim.new(0, 8)
	x.Parent = b

	local d = Instance.new("TextBox")
	d.Name = "Prediction"
	d.Parent = f
	d.Size = UDim2.new(0, 180, 0, 30)
	d.Position = UDim2.new(0, 10, 0, 80)
	d.Text = "0.1"
	d.PlaceholderText = "Prediction"
	d.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	d.TextColor3 = Color3.new(1, 1, 1)
	d.ClearTextOnFocus = false
	d.TextScaled = true

	local y = Instance.new("UICorner")
	y.CornerRadius = UDim.new(0, 8)
	y.Parent = d
end

local f = g.MainFrame
local b = f.Toggle
local d = f.Prediction

b.MouseButton1Click:Connect(function()
	aimbotInternalToggle = not aimbotInternalToggle
	b.Text = aimbotInternalToggle and "ON" or "OFF"
	b.BackgroundColor3 = aimbotInternalToggle and Color3.fromRGB(0, 150, 0) or Color3.fromRGB(40, 40, 40)
end)

d.FocusLost:Connect(function()
	local n = tonumber(d.Text)
	if n then
		aimbotPrediction = n
	end
end)

local function startBossFinder()
	if aimbotBossFinderConnection then
		aimbotBossFinderConnection:Disconnect()
	end
	aimbotBossFinderConnection = task.spawn(function()
		while aimbotEnabled do
			task.wait(2)
			if aimbotInternalToggle then
				local s = workspace:FindFirstChild("Sleepy Hollow")
				local m = s and s:FindFirstChild("Modes")
				local w = m and m:FindFirstChild("Boss")
				local k = w and w:FindFirstChild("HeadlessHorsemanBoss")
				aimbotBoss = k and k:FindFirstChild("HeadlessHorseman")
			else
				aimbotBoss = nil
			end
		end
		aimbotBoss = nil
	end)
end

local function startRenderStepped()
	if aimbotRenderConnection then
		aimbotRenderConnection:Disconnect()
	end
	aimbotRenderConnection = r.RenderStepped:Connect(function()
		if aimbotEnabled and aimbotInternalToggle and aimbotBoss and aimbotBoss.Parent then
			local e = aimbotBoss:FindFirstChild("Torso") or aimbotBoss:FindFirstChild("UpperTorso")
			if e then
				local q = e.Position + e.Velocity * aimbotPrediction
				c.CFrame = CFrame.new(c.CFrame.Position, q)
			end
		end
	end)
end

local function toggleAimbot(enabled)
	aimbotEnabled = enabled
	f.Visible = enabled
	
	if enabled then
		startBossFinder()
		startRenderStepped()
	else
		aimbotInternalToggle = false
		b.Text = "OFF"
		b.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
		aimbotBoss = nil
		if aimbotBossFinderConnection then
			task.cancel(aimbotBossFinderConnection)
			aimbotBossFinderConnection = nil
		end
		if aimbotRenderConnection then
			aimbotRenderConnection:Disconnect()
			aimbotRenderConnection = nil
		end
	end
end

-- GUI Creation with Error Handling
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

if not Rayfield then
    warn("Failed to load Rayfield library")
    return
end

local Window = Rayfield:CreateWindow({
    Name = "Chaos Hub",
    Icon = 0,
    LoadingTitle = "Chaos",
    LoadingSubtitle = "by Chaos Hub",
    Theme = "Ocean",
    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false,
    ConfigurationSaving = {
        Enabled = true,
        FolderName = nil,
        FileName = "G&B Hub"
    },
    Discord = {
        Enabled = true,
        Invite = "",
        RememberJoins = true
    }
})

local Tab = Window:CreateTab("Main", "album")
local Section = Tab:CreateSection("Main Functions")

local esp_Tab = Window:CreateTab("ESP", "target")
local esp_Section = esp_Tab:CreateSection("ESP Functions")

local player_Tab = Window:CreateTab("Player", "person-standing")
local player_Section = player_Tab:CreateSection("Aux. Player Functions")

local misc_Tab = Window:CreateTab("Misc", "settings")
local misc_Section = misc_Tab:CreateSection("Miscellaneous Functions")

local aimbot_Tab = Window:CreateTab("Aimbot", "crosshair")
local aimbot_Section = aimbot_Tab:CreateSection("Headless Horseman Aimbot")

-- Aimbot Tab Controls
local aimbotToggle = aimbot_Tab:CreateToggle({
    Name = "Headless Aimbot By Refs",
    CurrentValue = false,
    Flag = "HeadlessAimbot", 
    Callback = function(Value)
        toggleAimbot(Value)
        if Value then
            Rayfield:Notify({
                Title = "Headless Aimbot",
                Content = "Aimbot UI enabled - Lock onto the boss!",
                Duration = 3,
                Image = "crosshair"
            })
        else
            Rayfield:Notify({
                Title = "Headless Aimbot",
                Content = "Aimbot UI disabled.",
                Duration = 3,
                Image = "crosshair"
            })
        end
    end
})

-- Main Tab Controls
local walkSpeed = Tab:CreateToggle({
    Name = "WalkSpeed Freeze",
    CurrentValue = false,
    Flag = "WalkSpeed", 
    Callback = function(Value)
        walkSpeedToggled = Value
        changeWalkSpeed(walkSpeedValue, walkSpeedToggled)
    end
})

local Input = Tab:CreateInput({
   Name = "WalkSpeed",
   CurrentValue = "16",
   PlaceholderText = "WalkSpeed",
   RemoveTextAfterFocusLost = false,
   Flag = "Input1",
   Callback = function(Value)
       Value = tonumber(Value)
       if Value then
           walkSpeedValue = Value
           changeWalkSpeed(Value, walkSpeedToggled)
       end
   end
})

local killAura = Tab:CreateToggle({
    Name = "Kill Aura",
    CurrentValue = false,
    Flag = "KillAura", 
    Callback = function(Value)
        killAuraToggled = Value
        if Value then
            task.wait(0.5)
            createHitBox()
        else
            if not shoveAuraToggled then
                if killAuraConnection then
                    killAuraConnection:Disconnect()
                    killAuraConnection = nil
                end
                observerOnline = false
                isDead = false
                
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local hitbox = LocalPlayer.Character.HumanoidRootPart:FindFirstChild("Hitbox")
                    if hitbox then
                        hitbox:Destroy()
                    end
                end
            else
                createHitBox()
            end
        end
    end
})

local shoveAura = Tab:CreateToggle({
    Name = "Shove Aura",
    CurrentValue = false,
    Flag = "ShoveAura", 
    Callback = function(Value)
        shoveAuraToggled = Value
        if Value then
            task.wait(0.5)
            createHitBox()
        else
            if not killAuraToggled then
                if killAuraConnection then
                    killAuraConnection:Disconnect()
                    killAuraConnection = nil
                end
                observerOnline = false
                isDead = false
                
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local hitbox = LocalPlayer.Character.HumanoidRootPart:FindFirstChild("Hitbox")
                    if hitbox then
                        hitbox:Destroy()
                    end
                end
            else
                createHitBox()
            end
        end
    end
})

local shoveRadiusSlider = Tab:CreateSlider({
   Name = "Shove Radius",
   Range = {1, 15},
   Increment = 1,
   Suffix = " studs",
   CurrentValue = shoveRadius,
   Flag = "ShoveRadiusSlider",
   Callback = function(Value)
        setShoveRadius(Value)
   end
})

local maxShoveSlider = Tab:CreateSlider({
   Name = "Max Shove Per Cycle",
   Range = {1, 20},
   Increment = 1,
   Suffix = " zombies",
   CurrentValue = maxShovePerCycle,
   Flag = "MaxShoveSlider",
   Callback = function(Value)
        setMaxShovePerCycle(Value)
   end
})

local headToggle = Tab:CreateToggle({
    Name = "Head Lock",
    CurrentValue = false,
    Flag = "HeadLock", 
    Callback = function(Value)
        changeBayonet(Value)
        changeMelee(Value)
    end
})

local Lights = Tab:CreateButton({
    Name = "Lights On (Saint Petersburg)",
    Callback = function()
        pcall(onLights)
    end
})

local autoPlay = Tab:CreateToggle({
    Name = "Auto play",
    CurrentValue = false,
    Flag = "Autoplay", 
    Callback = function(Value)
        autoplay = Value
    end
})

local autoRepairToggle = Tab:CreateToggle({
    Name = "Auto Repair",
    CurrentValue = false,
    Flag = "AutoRepair",
    Callback = function(Value)
        autoRepair(Value)
    end
})

local autoEquipHammerToggle = Tab:CreateToggle({
    Name = "Auto Equip Hammer",
    CurrentValue = false,
    Flag = "AutoEquipHammer",
    Callback = function(Value)
        autoEquipHammerToggled = Value
    end
})

local hitboxExpanderToggle = Tab:CreateToggle({
    Name = "Zombie Hitbox Expander",
    CurrentValue = false,
    Flag = "HitboxExpander",
    Callback = function(Value)
        toggleHitboxExpander(Value)
        if Value then
            Rayfield:Notify({
                Title = "Hitbox Expander",
                Content = "Zombie hitboxes expanded to " .. hitboxSize .. " studs!",
                Duration = 3,
                Image = "crosshair"
            })
        else
            Rayfield:Notify({
                Title = "Hitbox Expander",
                Content = "Zombie hitboxes restored to normal.",
                Duration = 3,
                Image = "crosshair"
            })
        end
    end
})

local hitboxSizeSlider = Tab:CreateSlider({
   Name = "Zombie Hitbox Size",
   Range = {1, 30},
   Increment = 1,
   Suffix = " studs",
   CurrentValue = hitboxSize,
   Flag = "HitboxSizeSlider",
   Callback = function(Value)
        setHitboxSize(Value)
   end
})

-- Player Tab Controls
local player_esp = player_Tab:CreateToggle({
    Name = "Medic Player ESP",
    CurrentValue = false,
    Flag = "player_esp", 
    Callback = function(Value)
        espLifeToggled = Value
        checkPlayersLife()
    end
})

local priest_esp = player_Tab:CreateToggle({
    Name = "Father Infection ESP",
    CurrentValue = false,
    Flag = "father_infection", 
    Callback = function(Value)
        espLifeToggled = Value
        checkPlayersLife()
    end
})

-- ESP Tab Controls
local esp_Runner = esp_Tab:CreateToggle({
    Name = "ESP Runner",
    CurrentValue = false,
    Flag = "ESP_1",
    Callback = function(Value)
        espRToggled = Value
    end
})

local esp_Bomber = esp_Tab:CreateToggle({
    Name = "ESP Bomber",
    CurrentValue = false,
    Flag = "ESP_2",
    Callback = function(Value)
        espBToggled = Value
    end
})

local esp_Igniter = esp_Tab:CreateToggle({
    Name = "ESP Igniter",
    CurrentValue = false,
    Flag = "ESP_3",
    Callback = function(Value)
        espIToggled = Value
    end
})

local esp_Cuirassier = esp_Tab:CreateToggle({
    Name = "ESP Cuirassier",
    CurrentValue = false,
    Flag = "ESP_4",
    Callback = function(Value)
        espCuToogled = Value
    end
})

local esp_Boss = esp_Tab:CreateToggle({
    Name = "ESP Boss",
    CurrentValue = false,
    Flag = "ESP_5",
    Callback = function(Value)
        espBossToggled = Value
        if bossFolder then
            if Value then
                for _, child in pairs(bossFolder:GetChildren()) do
                    if not child:FindFirstChild("Highlight") then
                        local Highlight = Instance.new("Highlight")
                        Highlight.Parent = child
                        Highlight.Adornee = child
                        Highlight.FillColor = Color3.fromRGB(255, 0, 0)
                    end
                end
            else
                for _, child in pairs(bossFolder:GetChildren()) do
                    if child:FindFirstChild("Highlight") then
                        child.Highlight:Destroy()
                    end
                end
            end
        end
    end
})

-- Misc Tab Controls
local fullbrightToggle = misc_Tab:CreateToggle({
    Name = "Fullbright",
    CurrentValue = false,
    Flag = "Fullbright",
    Callback = function(Value)
        toggleFullbright(Value)
        if Value then
            Rayfield:Notify({
                Title = "Fullbright",
                Content = "Fullbright enabled - Maximum visibility!",
                Duration = 3,
                Image = "sun"
            })
        else
            Rayfield:Notify({
                Title = "Fullbright",
                Content = "Fullbright disabled - Lighting restored.",
                Duration = 3,
                Image = "moon"
            })
        end
    end
})

local killbrickToggle = misc_Tab:CreateToggle({
    Name = "Killbrick Protection",
    CurrentValue = false,
    Flag = "KillbrickProtection",
    Callback = function(Value)
        toggleKillbrick(not Value)
        if Value then
            Rayfield:Notify({
                Title = "Killbrick Protection",
                Content = "Protection enabled - You are now safe from killbricks!",
                Duration = 3,
                Image = "shield"
            })
        else
            Rayfield:Notify({
                Title = "Killbrick Protection",
                Content = "Protection disabled - Be careful!",
                Duration = 3,
                Image = "alert-triangle"
            })
        end
    end
})

local purchaseLeRevenant = misc_Tab:CreateButton({
    Name = "Purchase Le Revenant",
    Callback = function()
        local success, errorMsg = pcall(function()
            local args = {[1] = "Le Revenant"}
            game:GetService("ReplicatedStorage").Events.Customize.PurchaseEvent:FireServer(unpack(args))
            Rayfield:Notify({
                Title = "Purchase Attempt",
                Content = "Attempted to purchase Le Revenant.",
                Duration = 3,
                Image = "shopping-cart"
            })
        end)
        if not success then
            Rayfield:Notify({
                Title = "Purchase Error",
                Content = "Failed to purchase Le Revenant: " .. tostring(errorMsg),
                Duration = 5,
                Image = "alert-circle"
            })
        end
    end
})

local purchaseBaguette = misc_Tab:CreateButton({
    Name = "Purchase Baguette",
    Callback = function()
        local success, errorMsg = pcall(function()
            local args = {[1] = "Baguette"}
            game:GetService("ReplicatedStorage").Events.Customize.PurchaseEvent:FireServer(unpack(args))
            Rayfield:Notify({
                Title = "Purchase Attempt",
                Content = "Attempted to purchase Baguette.",
                Duration = 3,
                Image = "shopping-cart"
            })
        end)
        if not success then
            Rayfield:Notify({
                Title = "Purchase Error",
                Content = "Failed to purchase Baguette: " .. tostring(errorMsg),
                Duration = 5,
                Image = "alert-circle"
            })
        end
    end
})

end)

if not success then
    warn("Script Load Error: " .. tostring(errorMsg))
end
